#!/sbin/sh
#Dynamic Installer by @BlassGO
#Also uses code from @osm0sis and @topjohnwu

unmount() { ( umount "$1" || umount -l "$1";) 2>/dev/null; is_mounted "$1" && return 1 || return 0; }

write_raw_image() { local bs; if is_number $(string force remove M "$extraction_speed"); then bs=$extraction_speed; else bs=1048576; fi; dd if="$1" of="$2" bs=$bs; }

is_substring() { if [[ "$2" == *"$1"* ]]; then true; else false; fi; }

is_mounted() { grep -q " $(readlink -f "$1") " /proc/mounts 2>/dev/null; }

is_less() { compare $1 '<' $2 ;}

is_greater() { compare $1 '>' $2 ;}

is_less_equal() { compare $1 '<=' $2; }

is_greater_equal() { compare $1 '>=' $2; }

is_equal() { if [[ "$1" == "$2" ]]; then true; else false; fi; }

is_zip() { ( xxd -p "$1" | head -n1 | grep -q "504b0304" ) 2>/dev/null; }

is_gzip() { ( xxd -p "$1" | head -n1 | grep -q "1f8b08" ) 2>/dev/null; }

is_bzip() { ( xxd -p "$1" | head -n1 | grep -q "425a" ) 2>/dev/null; }

is_xz() { ( xxd -p "$1" | head -n1 | grep -q "fd377a585a00" ) 2>/dev/null; }

is_tar() { ( xxd -p -s 257 "$1" | head -n1 | grep -q "7573746172" ) 2>/dev/null; }

is_number() { echo "$1" | grep -Eq "^[0-9]+([.][0-9]+)?$"; }

is_hex() { echo "$1" | grep -Eq "^[[:xdigit:]]+$"; }

is_abc() { echo "$1" | tr -d '[[:space:]]' | grep -Eq "^[[:alpha:]]+$"; }

is_text() { echo "$1" | tr -d '[[:space:]]' | grep -Eq "^[[:print:]]+$"; }

is64bit() { local byte=$(od -An -t x1 -j 4 -N 1 "$1" | tr -d " "); if [[ "$byte" == "02" ]]; then return 0; elif [[ "$byte" == "01" ]]; then return 1; else echo Unknown && return 1; fi }

show_progress() { if ! $BOOTMODE; then echo "progress $1 $2" >> $OUTFD; fi }

apply_patch() { LD_LIBRARY_PATH=/system/lib$base_lib applypatch "$@"; }

apply_patch_check() { LD_LIBRARY_PATH=/system/lib$base_lib applypatch -c "$@"; }

apply_patch_space() { LD_LIBRARY_PATH=/system/lib$base_lib applypatch -s $1; }

rename() { mv -f "$1" "$2"; }

delete() { rm -f "$@"; }

delete_recursive() { rm -rf "$@"; }

repeat() { printf %${1}s | sed "s/ /$(string force escape "$2")/g"; }

calc() { awk "BEGIN{print $*}"; }

compare() { eval awk \"BEGIN\{if \(\!\("$@"\)\) exit 1\}\"; }

echo2() { >&2 echo "$@"; }

contains_array() { local e match="$1"; shift; for e; do [[ "$e" == "$match" ]] && return 0; done; return 1; }

get_array() { local e match="$1"; shift; for e; do [[ "$e" == *"$match"* ]] && echo "$e" && return 0; done; return 1; }

binarch() { local byte=$(od -An -t x1 -j 4 -N 1 "$1" | tr -d " "); if [[ "$byte" == "02" ]]; then echo 64bits; elif [[ "$byte" == "01" ]]; then echo 32bits; else echo Unknown && return 1; fi }

###################################
#Common EDIFY extra references (For new users)

file_getprop() { get_file_prop "$@"; }

ifelse() { eval "( $1 ) || ( $2 )"; }

read_file() { cat "$@"; }

run_program() { local program=$(fullpath "$1"); if [ ! -f "$program" ]; then echo2 "CANT FIND: $1" && return 1; fi ; shift; chmod 777 "$program"; "$program" "$@"; }

greater_than_int() { is_greater "$@"; }

less_than_int() { is_less "$@"; }

stdout() { "$@" 2>&1; }

#concat() { local con; for c; do con="${con}$($1 2>/dev/null || echo "$1")"; shift; done; [ -n "$con" ] && echo "$con" || return 1; }

concat() { local con; for c; do con="${con}$1"; shift; done; [ -n "$con" ] && echo "$con" || return 1; }


###################################

exist() {
   local func try count=0 restore flag file folder any
   restore=()
   while [[ $# -gt 0 ]]; do
   flag="$1"
   case $flag in
       file)
       file=true
       shift
       ;;
       folder)
       folder=true
       shift
       ;;
       any)
       any=true
       shift
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
   esac
   done
   set -- "${restore[@]}"
   func=$#
   if [[ "$func" == "0" ]]; then func=1; fi
   if [[ -z "$folder" && -z "$file" && -z "$any" ]]; then any=true; fi
   for try in "$@"; do
      if [[ -n "$file" && -f "$try" ]]; then count=$(( $count + 1 )); fi
      if [[ -n "$any" && -e "$try" ]]; then count=$(( $count + 1 )); fi
      if [[ -n "$folder" && -d "$try" ]]; then count=$(( $count + 1 )); fi
   done
   if [[ "$count" == "$func" ]]; then true; else false; fi
}

check_content() {
   local array file content func count=0
   array=( "$@" )
   file=${array[${#array[@]} - 1]}
   if [ ! -e "$file" ]; then echo "CANT FIND: $file" && return 1; fi
   if ! is_zip "$file"; then echo "check_content: $file inst a ZIP " && return 1; fi
   unset "array[${#array[@]}-1]"
   func=${#array[@]}
   if [[ "$func" == "0" ]]; then func=1; fi
   for content in "${array[@]}"; do
      if unzip -l "$file" | grep -q "$content"; then count=$(( $count + 1 )); fi
   done
   if [[ "$count" == "$func" ]]; then true; else false; fi
}

is_valid() {
   local count=0 func try
   func=$#
   if [[ "$func" == "0" ]]; then func=1; fi
   for try in "$@"; do
      if [ -e "$try" ] && grep -q '[^[:space:]]' "$try"; then count=$(( $count + 1 )); fi
   done
   if [[ "$count" == "$func" ]]; then true; else false; fi
}

defined() {
   local count=0 func try
   func=$#
   if [[ "$func" == "0" ]]; then func=1; fi
   for try in "$@"; do
      if [ -n "$(checkvar "$try")" ]; then count=$(( $count + 1 )); fi
   done
   if [[ "$count" == "$func" ]]; then true; else false; fi
}

undefined() {
   local count=0 func try
   func=$#
   if [[ "$func" == "0" ]]; then func=1; fi
   for try in "$@"; do
      if [ -z "$(checkvar "$try")" ]; then count=$(( $count + 1 )); fi
   done
   if [[ "$count" == "$func" ]]; then true; else false; fi
}

copy() {
   if ! $(cp -prf "$1" "$2" 2>/dev/null || [ ! -d "$(dirname "$2")" ] && mkdir -p "$(dirname "$2")" && cp -prf "$1" "$2"); then
      if [[ -d "$(dirname "$2")" && -z "$(ls -A "$(dirname "$2")")" ]]; then
         rm -rf "$(dirname "$2")"
         return 1
      else
         return 1
      fi
   else
      return 0
   fi
}

move() {
   if ! $(mv -f "$1" "$2" 2>/dev/null || [ ! -d "$(dirname "$2")" ] && mkdir -p "$(dirname "$2")" && mv -f "$1" "$2"); then
      if [[ -d "$(dirname "$2")" && -z "$(ls -A "$(dirname "$2")")" ]]; then
         rm -rf "$(dirname "$2")"
         return 1
      else
         return 1
      fi
   else
      return 0
   fi
}

fullpath() {
   local path fix='s/\/\/*/\//g'
   path=$(echo "$(cd "$(dirname "$1")" && pwd -P)/$(basename "$1")" | sed -e $fix)
   [ -e "$path" ] && echo "$path" || return 1
}

contains() {
   local array file content func count=0
   array=( "$@" )
   file=${array[${#array[@]} - 1]}
   if [ ! -e "$file" ]; then echo "CANT FIND: $file" && return 1; fi
   unset "array[${#array[@]}-1]"
   func=${#array[@]}
   if [[ "$func" == "0" ]]; then func=1; fi
   for content in "${array[@]}"; do
      if grep -Fq "$content" "$file"; then count=$(( $count + 1 )); fi
   done
   if [[ "$count" == "$func" ]]; then true; else false; fi
}

magic_file() {
   #Extra method:
   #od -An -v -w $bytes -t x1 -j $offset "$file" | tr -d " "
   local restore flag offset type line show showline bytes
   local magic file pass result get options return=0
   restore=()
   while [[ $# -gt 0 ]]; do
   flag="$1"
   case $flag in
       -offset|-o)
       offset=$2
       shift;shift;
       ;;
       -bytes|-b)
       bytes=$2
       shift;shift;
       ;;
       -type|-t)
       type=$2
       shift;shift;
       ;;
       -line|-l)
       line=$2
       shift;shift;
       ;;
       -show|-s)
       show=true
       shift
       ;;
       -show-line|-sl)
       showline=true
       shift
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
   esac
   done
   set -- "${restore[@]}"
   if [ -n "$type" ]; then
      file="$1"
      get=$(get_file_prop "$l/file_types.config" "$type " 2>/dev/null)
      if [ -n "$get" ]; then
        magic=$(echo "$get" | cut -d, -f1 | tr -d " " | tr : " ")
        options=$(echo "$get" | grep -o "," | wc -l)
        if [ "$options"  = "1" ]; then
           offset=$(echo "$get" | cut -d, -f2 | tr -d " ")
        elif [ "$options" = "2" ]; then
           offset=$(echo "$get" | cut -d, -f2 | tr -d " ")
           bytes=$(echo "$get" | cut -d, -f3 | tr -d " ")
        elif [ "$options" = "3" ]; then
           offset=$(echo "$get" | cut -d, -f2 | tr -d " ")
           bytes=$(echo "$get" | cut -d, -f3 | tr -d " ")
           line=$(echo "$get" | cut -d, -f4 | tr -d " ")
        fi
      else
        echo2 "magic_file: Cant find Magic Config for: $type" && return 1
      fi
   else
      magic="$1"
      file="$2"
   fi
   if [ -z "$magic" ]; then echo2 "magic_file: Null magic" && return 1; fi
   if [ ! -f "$file" ]; then echo2 "CANT FIND: $file" && return 1; fi
   if [ -n "$offset" ] && ! is_number "$offset"; then echo2 "magic_file: Invalid offset: $offset" && return 1; fi
   if [ -n "$line" ] && ! is_number "$line"; then echo2 "magic_file: Invalid line: $line" && return 1; fi
   if [ -n "$bytes" ] && ! is_number "$bytes"; then echo2 "magic_file: Invalid bytes: $bytes" && return 1; fi
   [ -z "$line" ] && line=1
   [ -z "$bytes" ] && bytes=100
   echo2 '>> Magic File v1.0.0'
   for magic in $magic; do
      result=
      pass=
      if ! is_hex "$magic"; then magic=$(printf "$magic" | od -An -t x1 | tr -d " "); fi
      echo2 " "
      echo2 " MAGIC: $magic"
      echo2 " FILE: $(basename "$file")"
      [ -n "$offset" ] && echo2 " OFFSET: $offset"
      [ -n "$bytes" ] && echo2 " BYTES: $bytes"
      if [ -z "$offset" ]; then result=$(( xxd -p -c $bytes "$file" | head -n$line ) 2>/dev/null)
      elif [ -n "$offset" ]; then result=$(( xxd -p -c $bytes -s $offset "$file" | head -n$line ) 2>/dev/null)
      fi
      pass=$(echo "$result" | grep -m1 "$magic")
      if [ -n "$showline" ]; then
         [ -n "$pass" ] && echo2 " LINE: $pass" || echo2 " LINE: NULL"
      elif [ -n "$show" ]; then
         if [ -n "$result" ]; then
            echo2 " RESULT: "
            echo2 "$result"
         else echo2 " RESULT: NULL"
         fi
      fi
      if [ -n "$pass" ]; then echo2 " PASSED: YES" && return 0
      else echo2 " PASSED: NO" && return=1 && continue
      fi
   done
   return $return
}

convert() {
   local num from to header group group2 section part result base base2 eq eq2 invert=false can can_too hm best conv first end pass=false try
   local restore flag d show=false
   local num1 num2 unit1 unit2
   restore=()
   while [[ $# -gt 0 ]]; do
   flag="$1"
   case $flag in
       -decimals|-d)
       d=$2
       shift;shift;
       ;;
       -show|-s)
       show=true
       shift
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
   esac
   done
   set -- "${restore[@]}"
   num1=$(echo "$1" | tr -d " " | grep -Eo "^[0-9]+([.][0-9]+)?")
   unit1=$(echo "$1" | grep -Eo "([[:alpha:]]|[[:punct:]])+([0-9]+)?" | tail -n1)
   unit2=$(echo "$2" | grep -Eo "([[:alpha:]]|[[:punct:]])+([0-9]+)?" | tail -n1)
   if [ -z "$unit1" ] && [ -n "$convert_from" ]; then unit1=$convert_from; fi
   if [ -z "$unit2" ] && [ -n "$convert_to" ]; then unit2=$convert_to; fi
   is_number "$d" || d=16
   if defined unit1 && defined unit2; then
      is_number "$num1" && num=$num1 || num=1; from=$unit1; to=$unit2
   else echo2 "convert: Invalid line" && return 1
   fi
   header=$(grep -E -m1 "[\[]+[[:alpha:]]+([[:punct:]])?+[/:].*[\"]$from[\"].*" "$l/units.config")
   group=$(echo "$header" | cut -d: -f1 | tr -d "[]")
   if [ -z "$group" ]; then echo2 "Cant find any group for: $from unit" && return 1; fi
   section=$(string extract "[$group:" "[$group end" -f "$l/units.config")
   if [ -z "$section" ]; then echo2 "Empty group: $group" && return 1; fi
   part=$(echo "$section" | grep -E -wm1 "[0-9]+([.][0-9]+)?+$from = [0-9]+([.][0-9]+)?+$to")
   if [ -z "$part" ]; then
      part=$(echo "$section" | grep -E -wm1 "[0-9]+([.][0-9]+)?+$to = [0-9]+([.][0-9]+)?+$from")
      if [ -n "$part" ]; then invert=true
      else
         group2=$(grep -E -m1 "[\[]+[[:alpha:]]+([[:punct:]])?+[/:].*[\"]$to[\"].*" "$l/units.config" | cut -d: -f1 | tr -d "[]")
         if [ -n "$group2" ] && [ "$group" == "$group2" ]; then
            can=$(echo "$section" | grep -E -w "[0-9]+([.][0-9]+)?+$to" | tr ' ' '\n' | grep -Eo "([[:alpha:]]|[[:punct:]])+([0-9]+)?" | grep -Ev "[0-9]+([.][0-9]+)?" | grep -E -wv "($to|=)" | tr '\n' ' ' )
            range=$(echo "$header" | grep -Eo "([\"]$from[\"].*[\"]$to[\"])?([\"]$to[\"].*[\"]$from[\"])?" | tr '"' ' ')
            if [[ "$(echo "$range" | awk '{print $1;}')" == "$to" ]]; then range=$(echo "$range" | tr ' ' '\n'| tac |tr '\n' ' '); fi
            range=$(echo "$range" | tr ' ' '\n' | grep -E -wv "($from|$to)" |  tr '\n' ' ')
            for hm in $can; do
               can_too="$can_too $(echo "$section" | grep -E -w "[0-9]+([.][0-9]+)?+$hm" | tr ' ' '\n' | grep -Eo "([[:alpha:]]|[[:punct:]])+([0-9]+)?" | grep -Ev "[0-9]+([.][0-9]+)?" | grep -E -wv "($hm|$to|=)" | tr '\n' ' ')"
            done
            for test in $can; do
               if echo "$section" | grep -Eq -wm1 "[0-9]+([.][0-9]+)?+($test|$from) = [0-9]+([.][0-9]+)?+($from|$test)"; then
                  best="$best $test"
               fi
            done
            if [ -z "$best" ]; then
               for test in $can; do
                  for test2 in $can_too; do
                     if echo "$section" | grep -Eq -wm1 "[0-9]+([.][0-9]+)?+($test2|$test) = [0-9]+([.][0-9]+)?+($test|$test2)"; then
                        #echo "$test2 $test"
                        if echo "$section" | grep -Eq -wm1 "[0-9]+([.][0-9]+)?+($test2|$from) = [0-9]+([.][0-9]+)?+($from|$test2)"; then
                           best="$best $test2 $test"
                           break
                        fi
                     fi
                  done
               done
            fi
            #echo "CAN:"
            #echo "$can"
            #echo "CAN TOO:"
            #echo "$can_too"
            #echo "BEST:"
            #echo "$best"
            #echo "RANGE:"
            #echo "$range"
            first=$(echo "$best" | awk '{print $1;}')
            end=$(echo "$best" | awk '{print $NF}')
            if echo "$section" | grep -Eq -wm1 "[0-9]+([.][0-9]+)?+($first|$from) = [0-9]+([.][0-9]+)?+($from|$first)" && echo "$section" | grep -Eq -wm1 "[0-9]+([.][0-9]+)?+($end|$to) = [0-9]+([.][0-9]+)?+($to|$end)"; then pass=true; fi
            if ! $pass && [ -n "$range" ]; then
               best="$range"
               first=$(echo "$best" | awk '{print $1;}')
               end=$(echo "$best" | awk '{print $NF}')
               if echo "$section" | grep -Eq -wm1 "[0-9]+([.][0-9]+)?+($first|$from) = [0-9]+([.][0-9]+)?+($from|$first)" && echo "$section" | grep -Eq -wm1 "[0-9]+([.][0-9]+)?+($end|$to) = [0-9]+([.][0-9]+)?+($to|$end)"; then pass=true; fi
            fi
            if ! $pass; then
               echo2 "Oops: Cant generate an automatic conversion sequence for: $from to $to"
               return 1
            fi
            for conv in $best; do
               invert=false
               runit2=$from
               runit=$conv
               part=$(echo "$section" | grep -E -wm1 "[0-9]+([.][0-9]+)?+$from = [0-9]+([.][0-9]+)?+$conv")
               if [ -z "$part" ]; then
                  part=$(echo "$section" | grep -E -wm1 "[0-9]+([.][0-9]+)?+$conv = [0-9]+([.][0-9]+)?+$from")
                  invert=true
               fi
               if [ -n "$part" ]; then
                  #echo "$part"
                  from=$runit
                  base=$(echo "$part" | cut -d= -f1 | tr -d " " | grep -Eo "^[0-9]+([.][0-9]+)?")
                  base2=$(echo "$part" | cut -d= -f2 | tr -d " " | grep -Eo "^[0-9]+([.][0-9]+)?")
                  [ -z "$base" ] && eq=1 || eq=$base
                  [ -z "$base2" ] && eq2=1 || eq2=$base2
                  $invert && eq=$base2
                  $invert && eq2=$base
                  num=$(calc '(' $num '*' $eq2 ')' / $eq)
                  $show && echo "$num$runit"
               fi
               invert=false
            done
         elif [ -n "$group2" ] && [ "$group" != "$group2" ]; then echo2 "Hm you try to convert a unit from group $group to a unit from group $group2" && return 1 
         else echo2 "Oops: Cant find $from to $to conversion in group $group" && return 1
         fi
      fi
   fi
   if [ "$from" != "$unit1" ]; then
      part=$(echo "$section" | grep -E -wm1 "[0-9]+([.][0-9]+)?+$from = [0-9]+([.][0-9]+)?+$to")
      if [ -z "$part" ]; then
         part=$(echo "$section" | grep -E -wm1 "[0-9]+([.][0-9]+)?+$to = [0-9]+([.][0-9]+)?+$from")
         if [ -n "$part" ]; then invert=true
         else
            echo2 "Oops: Cant continue the conversion sequence"
            echo2 "Sequence: $best"
            echo2 "Cant: $num$from to $to"
            return 1
         fi
      fi
   fi
   base=$(echo "$part" | cut -d= -f1 | tr -d " " | grep -Eo "^[0-9]+([.][0-9]+)?")
   base2=$(echo "$part" | cut -d= -f2 | tr -d " " | grep -Eo "^[0-9]+([.][0-9]+)?")
   [ -z "$base" ] && eq=1 || eq=$base
   [ -z "$base2" ] && eq2=1 || eq2=$base2
   $invert && eq=$base2
   $invert && eq2=$base
   result=$(calc '(' $num '*' $eq2 ')' / $eq)
   #Ensure decimal numbers / fully integers
   result=$(printf "%.${d}f" "$result" | sed '/\./ s/\.\{0,1\}0\{1,\}$//')
   if is_number "$result"; then 
      $show && echo $result$to || echo $result
   else return 1
   fi
}

abort() {
   ui_print "$@"
   umount_all
   [ -n "$MODPATH" ] && delete_recursive "$MODPATH"
   remove_tmp
   restore_env
   exit 130
}

bin_info() {
   local check
   if ! grep -wm1 "$1" "$l/info.txt" 2>/dev/null; then
      if [ -f "$1" ]; then
         check=$(binarch "$1")
         if [[ $check == 64bits ]]; then echo "$(basename "$1"): 64bits"
         elif [[ $check == 32bits ]]; then echo "$(basename "$1"): 32bits"
         else echo "$(basename "$1"): Unknown"
         fi
      elif [ -f "$(command -v "$1")" ]; then
         check=$(binarch "$(command -v "$1")")
         if [[ $check == 64bits ]]; then echo "$1: 64bits"
         elif [[ $check == 32bits ]]; then echo "$1: 32bits"
         else echo "$1: Unknown"
         fi
      else return 1
      fi
   fi
}

wipe() {
   #wipe system vendor data
   local wipe return=0
   for wipe in "$@"; do
      if [[ "$wipe" == "data" ]]; then
         if ! try_mount -e -rw /data; then echo "CANT WIPE: /data" && return=1 && continue; fi
         echo2 " -- Wiping /data"
         find /data -mindepth 1 ! -regex "/data/media.*" -delete
      elif [[ "$wipe" == "userdata" ]]; then
         if ! try_mount -e -rw /data; then echo "CANT WIPE: /data and /data/media" && return=1 && continue; fi
         echo2 " -- Wiping /data and /data/media"
         rm -rf /data/*
      elif [[ "$wipe" == "dalvik" ]]; then
         if ! try_mount -e -rw /data; then echo "CANT WIPE: /data/dalvik-cache" && return=1 && continue; fi
         echo2 " -- Wiping /data/dalvik-cache"
         rm -rf /data/dalvik-cache
      else
         if ! try_mount -rw "/$wipe"; then echo "CANT WIPE: /$wipe" && return=1 && continue; fi
         echo2 " -- Wiping /$wipe"
         rm -rf /$wipe/*
         unmount "/$wipe"
      fi
   done
   return $return
}

set_metadata() {
  local file i;
  file="$1";
  shift;
  while [ "$2" ]; do
    case $1 in
      uid) chown $2 "$file";;
      gid) chown :$2 "$file";;
      mode) chmod $2 "$file";;
      capabilities) twrp setcap "$file" $2;;
      selabel)
        chcon -h $2 "$file" || chcon $2 "$file";
      ;;
      *) ;;
    esac;
    shift 2;
  done;
}

update_file() {
   local file get newprop prop result propc xml test newprop2 space split
   local restore flag tmp huh save result save2 save3 TMP2
   restore=()
   while [[ $# -gt 0 ]]; do
   flag="$1"
   case $flag in
       -delim|-d)
       save=("$1" "$2" "$3")
       shift;shift;shift;
       ;;
       -no-spaces|-ns)
       save2=("$1")
       shift
       ;;
       -p|-pattern)
       save3=("$1" "$2")
       shift;shift;
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
   esac
   done
   set -- "${restore[@]}"
   file="$2"
   if [ ! -e "$file" ]; then echo "CANT FIND: $file" && return 1; fi
   if [ ! -e "$1" ]; then echo "CANT FIND: $1" && return 1; fi
   start_tmp
   tmp="$TMP2/$(basename "$file")"
   cat "$file" > "$tmp"
   while IFS='' read -r prop || [[ -n "$prop" ]]; do
         huh+=("$prop")
   done < "$1"
   update_file_string "${save[@]}" "${save2[@]}" "${save3[@]}" "${huh[@]}" "$tmp"
   result=$?
   inject "$tmp" "$(dirname "$file")"
   end_tmp
   return $result
}

update_file_string() {
   local vars file array newprop prop propc xml result new old
   local restore flag d d2 huh tmp extract newprop2 backdir space space2 newspace nospace
   local p
   restore=()
   while [[ $# -gt 0 ]]; do
   flag="$1"
   case $flag in
       -delim|-d)
       d="$2"
       d2="$3"
       shift;shift;shift;
       ;;
       -no-spaces|-ns)
       nospace=true
       shift
       ;;
       -p|-pattern)
       p="$2"
       shift;shift;
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
   esac
   done
   set -- "${restore[@]}"
   array=( "$@" )
   file=${array[${#array[@]} - 1]}
   if [ ! -e "$file" ]; then echo "CANT FIND: $file" && return 1; fi
   savestate old "$file"
   tmp="$TMP/$(basename "$file")"
   unset "array[${#array[@]}-1]"
   cat "$file" > "$tmp"
   if [ -n "$d" ]; then
      huh=$(cat "$file")
      backdir="$file"
      if [ -z "$p" ]; then
         extract=$(string complete_extract "$d" "$d2" "$huh")
      else
         extract=$(string -r -p "$p" complete_extract "$d" "$d2" "$huh")
      fi
      file="$tmp"
      if [ -n "$extract" ]; then echo "$extract" > "$tmp"; else echo "CANT GET CONTENT: $d $d2" && return 1; fi
   fi
   for prop in "${array[@]}"; do
         if [ -z "$prop" ]; then continue; fi
         newprop=
         propc=
         xml=
         space=
         space2=
         newspace=
         test "${prop#*=}" != "$prop" && propc=1
         test "${prop#*/>}" != "$prop" && xml=1
         test "${prop#*</}" != "$prop" && xml=1
         if [[ -n "$xml" && -n "$propc" ]]; then propc=0; fi
         if [[ "$xml" == "1" ]]; then
             newprop=$(string inside_symbol '="' '"' "$prop")
             newprop2=$(string inside_symbol ' ' ='"'$newprop'"' "$prop") 
             if [ -n "$newprop" ]; then
               if [[ $(grep -o "$newprop2" "$file" | wc -l) == "1"  ]]; then
                  newprop="$newprop2"
               elif ! is_substring "$newprop2" "$(grep -m1 "$newprop" "$file")"; then
                  newprop=
               fi
             fi
             if [[ -z "$newprop" || "$newprop" == "$prop" ]]; then
                if is_substring '</' "$prop"; then
                   newprop=$(echo "$prop" | sed -e 's/.*<\/\(.*\)>.*/\1/') 
                elif is_substring '/>' "$prop"; then
                   newprop=$(echo "$prop" | sed -e 's/.*<\(.*\)\/>.*/\1/')
                fi
             fi
             if [[ -n "$newprop" && "$newprop" != "$prop" ]]; then
                space=$(grep -m1 "$newprop" "$file" | cut -d'<' -f1)
                space2=$(echo "$prop" | cut -d'<' -f1)
                if [[ "$space" != "$space2" && -z "$nospace" ]]; then
                   newspace="$space"
                fi
             else
                newprop=
                echo2 " WARNING: Abnormal xml $prop"
             fi
         fi   
         if [[ "$propc" == "1" ]]; then  
             newprop=$(echo "$prop" | cut -d '=' -f1 | tr -d " ")
         fi  
         if [ -z "$newprop" ]; then continue; fi
         echo2 "::$newprop"
         prop=$(echo "${newspace}${prop}" | sed -e 's/[]\/$*.^[]/\\&/g')
         result=$(sed "s/.*$(string force escape "$newprop").*/${prop}/" "$tmp")
         if [ ! -z "$result" ]; then echo "$result" > "$tmp"; fi
   done
   if [ -n "$d" ]; then
      file="$backdir"
      echo "${huh/$extract/$result}" > "$tmp"
   fi
   if ! is_valid "$tmp"; then echo2 " FATAL ERROR: Invalid $tmp " && return 1; fi
   inject "$tmp" "$(dirname "$file")"
   rm -f "$tmp"
   savestate new "$file"
   if [[ "$old" != "$new" ]]; then true; else false; fi
}

update_file_addon() {
   local restore flag save save2 save3
   restore=()
   while [[ $# -gt 0 ]]; do
   flag="$1"
   case $flag in
       -delim|-d)
       save=("$1" "$2" "$3")
       shift;shift;shift;
       ;;
       -no-spaces|-ns)
       save2=("$1")
       shift
       ;;
       -p|-pattern)
       save3=("$1" "$2")
       shift;shift;
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
   esac
   done
   set -- "${restore[@]}"
   update_file "${save[@]}" "${save2[@]}" "${save3[@]}" "$addons/$1" "$2"
}

update_file_zip() {
   local restore flag save result save2 save3 tmp TMP2
   restore=()
   while [[ $# -gt 0 ]]; do
   flag="$1"
   case $flag in
       -delim|-d)
       save=("$1" "$2" "$3")
       shift;shift;
       ;;
       -no-spaces|-ns)
       save2=("$1")
       shift
       ;;
       -p|-pattern)
       save3=("$1" "$2")
       shift;shift;
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
   esac
   done
   set -- "${restore[@]}"
   start_tmp
   tmp="$TMP2/update.tmp"
   package_extract_file "$1" "$tmp"
   update_file "${save[@]}" "${save2[@]}" "${save3[@]}" "$tmp" "$2"
   result=$?
   end_tmp
   return $result
}

force_update_file() {
   local file get newprop prop result propc xml test newprop2 space split
   local restore flag tmp huh save save2 save3 TMP2
   restore=()
   while [[ $# -gt 0 ]]; do
   flag="$1"
   case $flag in
       -delim|-d)
       save=("$1" "$2" "$3")
       shift;shift;shift;
       ;;
       -no-spaces|-ns)
       save2=("$1")
       shift
       ;;
       -p|-pattern)
       save3=("$1" "$2")
       shift;shift;
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
   esac
   done
   set -- "${restore[@]}"
   file="$2"
   if [ ! -e "$file" ]; then echo "CANT FIND: $file" && return 1; fi
   if [ ! -e "$1" ]; then echo "CANT FIND: $1" && return 1; fi
   start_tmp
   tmp="$TMP2/$(basename "$file")"
   cat "$file" > "$tmp"
   while IFS='' read -r prop || [[ -n "$prop" ]]; do
         huh+=("$prop")
   done < "$1"
   force_update_file_string "${save[@]}" "${save2[@]}" "${save3[@]}" "${huh[@]}" "$tmp"
   result=$?
   inject "$tmp" "$(dirname "$file")"
   end_tmp
   return $result
}

force_update_file_string() {
   local vars file array newprop prop propc xml result old new
   local restore flag d d2 huh tmp extract newprop2 limit backdir space space2 newspace nospace
   local p
   restore=()
   while [[ $# -gt 0 ]]; do
   flag="$1"
   case $flag in
       -delim|-d)
       d="$2"
       d2="$3"
       shift;shift;shift;
       ;;
       -no-spaces|-ns)
       nospace=true
       shift
       ;;
       -p|-pattern)
       p="$2"
       shift;shift;
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
   esac
   done
   set -- "${restore[@]}"
   array=( "$@" )
   file=${array[${#array[@]} - 1]}
   if [ ! -e "$file" ]; then echo "CANT FIND: $file" && return 1; fi
   savestate old "$file"
   tmp="$TMP/$(basename "$file")"
   unset "array[${#array[@]}-1]"
   cat "$file" > "$tmp"
   if [ -n "$d" ]; then
      huh=$(cat "$file")
      backdir="$file"
      if [ -z "$p" ]; then
         extract=$(string complete_extract "$d" "$d2" "$huh")
      else
         extract=$(string -r -p "$p" complete_extract "$d" "$d2" "$huh")
      fi
      file="$tmp"
      if [ -n "$extract" ]; then echo "$extract" > "$tmp"; else echo "CANT GET CONTENT: $d $d2" && return 1; fi
   fi
   for prop in "${array[@]}"; do
         limit=$(($limit + 1))
         newprop=
         propc=
         xml=
         space=
         space2=
         newspace=
         test "${prop#*=}" != "$prop" && propc=1
         test "${prop#*/>}" != "$prop" && xml=1
         test "${prop#*</}" != "$prop" && xml=1
         if [[ -n "$xml" && -n "$propc" ]]; then propc=0; fi
         if [[ "$xml" == "1" ]]; then
             newprop=$(string inside_symbol '="' '"' "$prop")
             newprop2=$(string inside_symbol ' ' ='"'$newprop'"' "$prop") 
             if [ -n "$newprop" ]; then
               if [[ $(grep -o "$newprop2" "$file" | wc -l) == "1"  ]]; then
                  newprop="$newprop2"
               elif ! is_substring "$newprop2" "$(grep -m1 "$newprop" "$file")"; then
                  newprop=
               fi
             fi
             if [[ -z "$newprop" || "$newprop" == "$prop" ]]; then
                if is_substring '</' "$prop"; then
                   newprop=$(echo "$prop" | sed -e 's/.*<\/\(.*\)>.*/\1/') 
                elif is_substring '/>' "$prop"; then
                   newprop=$(echo "$prop" | sed -e 's/.*<\(.*\)\/>.*/\1/')
                fi
             fi
             if [[ -n "$newprop" && "$newprop" != "$prop" ]]; then
                space=$(grep -m1 "$newprop" "$file" | cut -d'<' -f1)
                space2=$(echo "$prop" | cut -d'<' -f1)
                if [[ "$space" != "$space2" && -z "$nospace" ]]; then
                   newspace="$space"
                fi
             else
                newprop=
                echo2 " WARNING: Abnormal xml $prop"
             fi
         fi   
         if [[ "$propc" == "1" ]]; then  
             newprop=$(echo "$prop" | cut -d '=' -f1 | tr -d " ")
         fi  
         if [ -z "$newprop" ]; then continue; fi
         if [[ "$xml" == "1" && "$limit" == "1" ]]; then
             sed -i '/^$/d' "$tmp"
             last=$(tail -n 1 "$tmp")
             sed -i '$d' "$tmp"
         fi   
         echo2 "::$newprop"
         result=$(awk "!/$(string force escape "$newprop")/" "$tmp")
         if [ ! -z "$result" ]; then echo "$result" > "$tmp"; fi
         echo "${newspace}${prop}" >> "$tmp"
   done
   if [[ "$xml" == "1" ]]; then
       echo "$last" >> "$tmp"
   fi
   result=$(cat "$tmp")
   if [ -n "$d" ]; then
      file="$backdir"
      echo "${huh/$extract/$result}" > "$tmp"
   fi
   if ! is_valid "$tmp"; then echo2 " FATAL ERROR: Invalid $tmp " && return 1; fi
   inject "$tmp" "$(dirname "$file")"
   rm -f "$tmp"
   savestate new "$file"
   if [[ "$old" != "$new" ]]; then true; else false; fi
}

force_update_file_addon() {
   local restore flag save save2 save3
   restore=()
   while [[ $# -gt 0 ]]; do
   flag="$1"
   case $flag in
       -delim|-d)
       save=("$1" "$2" "$3")
       shift;shift;shift;
       ;;
       -no-spaces|-ns)
       save2=("$1")
       shift
       ;;
       -p|-pattern)
       save3=("$1" "$2")
       shift;shift;
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
   esac
   done
   set -- "${restore[@]}"
   force_update_file "${save[@]}" "${save2[@]}" "${save3[@]}" "$addons/$1" "$2"
}

force_update_file_zip() {
   local restore flag save result save2 save3 tmp TMP2
   restore=()
   while [[ $# -gt 0 ]]; do
   flag="$1"
   case $flag in
       -delim|-d)
       save=("$1" "$2" "$3")
       shift;shift;shift;
       ;;
       -no-spaces|-ns)
       save2=("$1")
       shift
       ;;
       -p|-pattern)
       save3=("$1" "$2")
       shift;shift;
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
   esac
   done
   set -- "${restore[@]}"
   start_tmp
   tmp="$TMP2/update.tmp"
   package_extract_file "$1" "$tmp"
   force_update_file "${save[@]}" "${save2[@]}" "${save3[@]}" "$tmp" "$2"
   result=$?
   end_tmp
   return $result
}

flash() {
	unzip -qp "$2" "META-INF/com/google/android/update-binary" > "$TMP/update-binary-test"
    chmod +x "$TMP/update-binary-test"
    setdefault "$1" "$("$TMP/update-binary-test" 3 3 "$2" 2>&1)"
}

flash_addon() {
   flash "$1" "$addons/$2"
}

flash_zip() {
    package_extract_file "$2" "$TMP/$(basename "$2")"
    flash "$1" "$TMP/$(basename "$2")"
    rm -f "$TMP/$(basename "$2")"
}

add_lines() { 
    local old new restore flag al al_add bl bl_add file tmp array lines i TMP2
    restore=()
    while [[ $# -gt 0 ]]; do
    flag="$1"
    case $flag in
       -al|-after-line)
       al+=("$2")
       al_add+=("$3")
       shift;shift;shift;
       ;;
       -bl|-before-line)
       bl+=("$2")
       bl_add+=("$3")
       shift;shift;shift;
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
    esac
    done
    set -- "${restore[@]}"
    array=( "$@" )
    file=${array[${#array[@]} - 1]}
    if [ ! -e "$file" ]; then echo "CANT FIND: $file" && return 1; fi
    unset "array[${#array[@]}-1]"
    start_tmp 
    tmp="$TMP2/$(basename "$file")"
    cat "$file" > "$tmp"
    for lines in "${array[@]}"; do
       cat "$lines" >> "$tmp"
    done
    for i in "${!al[@]}"; do
       add_lines_string -al "${al[i]}" "$(cat "${al_add[i]}")" "$tmp"
    done
    for i in "${!bl[@]}"; do
       add_lines_string -bl "${bl[i]}" "$(cat "${bl_add[i]}")" "$tmp"
    done
    savestate old "$file"
    if ! is_valid "$tmp"; then echo2 " FATAL ERROR: Invalid $tmp" && return 1; fi
    inject "$tmp" "$(dirname "$file")"
    end_tmp
    savestate new "$file"
    if [[ "$old" != "$new" ]]; then true; else false; fi
}

add_lines_string() {
    local vars file array lines restore flag get try
    local al al_add bl bl_add i old new
    restore=()
    while [[ $# -gt 0 ]]; do
    flag="$1"
    case $flag in
       -al|-after-line)
       al+=("$2")
       al_add+=("$3")
       shift;shift;shift;
       ;;
       -bl|-before-line)
       bl+=("$2")
       bl_add+=("$3")
       shift;shift;shift;
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
    esac
    done
    set -- "${restore[@]}"
    array=( "$@" )
    file=${array[${#array[@]} - 1]}
    if [ ! -e "$file" ]; then echo "CANT FIND: $file" && return 1; fi
    savestate old "$file"
    unset "array[${#array[@]}-1]"
	cat "$file" > "$TMP/$(basename "$file")"
	for lines in "${array[@]}"; do
	   echo "$lines" >> "$TMP/$(basename "$file")"
	done
    if [ -n "$al" ]; then
       for i in "${!al[@]}"; do
          try=$(string -f "$TMP/$(basename "$file")" -after-line "${al[i]}" "${al_add[i]}")
          [ -n "$try" ] && echo "$try" > "$TMP/$(basename "$file")"
       done
    fi
    if [ -n "$bl" ]; then
       for i in "${!bl[@]}"; do
          try=$(string -f "$TMP/$(basename "$file")" -before-line "${bl[i]}" "${bl_add[i]}")
          [ -n "$try" ] && echo "$try" > "$TMP/$(basename "$file")"
       done
    fi
    if ! is_valid "$TMP/$(basename "$file")"; then echo2 " FATAL ERROR: Invalid $TMP/$(basename "$file") " && return 1; fi
    inject "$TMP/$(basename "$file")" "$(dirname "$file")"
    rm -f "$TMP/$(basename "$file")"
    savestate new "$file"
    if [[ "$old" != "$new" ]]; then true; else false; fi
}

add_lines_addon() {
    local old new restore flag al al_add bl bl_add file tmp array lines i TMP2
    restore=()
    while [[ $# -gt 0 ]]; do
    flag="$1"
    case $flag in
       -al|-after-line)
       al+=("$2")
       al_add+=("$3")
       shift;shift;shift;
       ;;
       -bl|-before-line)
       bl+=("$2")
       bl_add+=("$3")
       shift;shift;shift;
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
    esac
    done
    set -- "${restore[@]}"
    array=( "$@" )
    file=${array[${#array[@]} - 1]}
    if [ ! -e "$file" ]; then echo "CANT FIND: $file" && return 1; fi
    unset "array[${#array[@]}-1]"
    start_tmp 
    tmp="$TMP2/$(basename "$file")"
    cat "$file" > "$tmp"
    for lines in "${array[@]}"; do
       cat "$addons/$lines" >> "$tmp"
    done
    for i in "${!al[@]}"; do
       add_lines_string -al "${al[i]}" "$(cat "$addons/${al_add[i]}")" "$tmp"
    done
    for i in "${!bl[@]}"; do
       add_lines_string -bl "${bl[i]}" "$(cat "$addons/${bl_add[i]}")" "$tmp"
    done
    savestate old "$file"
    if ! is_valid "$tmp"; then echo2 " FATAL ERROR: Invalid $tmp" && return 1; fi
    inject "$tmp" "$(dirname "$file")"
    end_tmp
    savestate new "$file"
    if [[ "$old" != "$new" ]]; then true; else false; fi
}

add_lines_zip() {
    local old new restore flag al al_add bl bl_add file tmp array lines i TMP2
    restore=()
    while [[ $# -gt 0 ]]; do
    flag="$1"
    case $flag in
       -al|-after-line)
       al+=("$2")
       al_add+=("$3")
       shift;shift;shift;
       ;;
       -bl|-before-line)
       bl+=("$2")
       bl_add+=("$3")
       shift;shift;shift;
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
    esac
    done
    set -- "${restore[@]}"
    array=( "$@" )
    file=${array[${#array[@]} - 1]}
    if [ ! -e "$file" ]; then echo "CANT FIND: $file" && return 1; fi
    unset "array[${#array[@]}-1]"
    start_tmp 
    tmp="$TMP2/$(basename "$file")"
    cat "$file" > "$tmp"
    for lines in "${array[@]}"; do
       delete "$TMP2/add.tmp"
       package_extract_file "$lines" "$TMP2/add.tmp"
       cat "$TMP2/add.tmp" >> "$tmp"
    done
    for i in "${!al[@]}"; do
       delete "$TMP2/add.tmp"
       package_extract_file "${al_add[i]}" "$TMP2/add.tmp"
       add_lines_string -al "${al[i]}" "$(cat "$TMP2/add.tmp")" "$tmp"
    done
    for i in "${!bl[@]}"; do
       delete "$TMP2/add.tmp"
       package_extract_file "${bl_add[i]}" "$TMP2/add.tmp"
       add_lines_string -bl "${bl[i]}" "$(cat "$TMP2/add.tmp")" "$tmp"
    done
    savestate old "$file"
    if ! is_valid "$tmp"; then echo2 " FATAL ERROR: Invalid $tmp" && return 1; fi
    inject "$tmp" "$(dirname "$file")"
    end_tmp
    savestate new "$file"
    if [[ "$old" != "$new" ]]; then true; else false; fi
}

setup_bb() {
   #Ensure /system/bin/sh
   if [ ! -f /system/bin/sh ]; then
      umount -l /system 2>/dev/null
      mkdir -p /system/bin
      ln -sf "$(command -v sh)" /system/bin/sh
   fi
   if [ -e "$bb" ]; then
     if ! "$bb" --install -s "$l"; then
        for i in $("$bb" --list); do
          if ! ln -sf "$bb" "$l/$i" && ! "$bb" ln -sf "$bb" "$l/$i" && ! "$bb" ln -f "$bb" "$l/$i"; then
            # create script wrapper if symlinking and hardlinking failed because of restrictive selinux policy
            if ! echo "#!$bb" > "$l/$i" || ! chmod 755 "$l/$i"; then
              abort "ERROR:1: Failed to setup busybox"
            fi
          fi
        done
     fi
   else
      abort "ERROR:2: Cant find busybox"
   fi
   if [ ! -f "$l/sh" ]; then abort "ERROR:3: Failed to setup busybox"; fi
}

get() {
  #Get v1.2.0
  #Ensure Extraction
  local var flag from to in get rm root
  for var; do
    flag="$1"
    case $flag in
       -from)
       from="$2"
       shift 2
       ;;
       -to)
       to="$2"
       shift 2
       ;;
       -in)
       in="$2"
       shift 2
       ;;
       *)
       set -- "$@" "$1"
       shift
       ;;
    esac
  done
  if [ -z "$from" ] || [ ! -f "$from" ]; then abort "ERROR: Invalid ZIP name"; fi
  [ -n "$in" ] && in="$in/"
  [ -n "$to" ] && to="$to/" || to="$PWD/"
  [ "$to" == "//" ] && to=/
  for get in "$@"; do
     root="${in}$get"
     echo2 "Getting: $get"
     unzip -qo "$from" "$root" -d "$to"
     if [ -f "${to}$root" ]; then
        mv -f "${to}$root" "${to}$get"
        chmod 755 "${to}$get"
        if [ -f "${to}$get" ]; then
           rm=${root%%/*}
           [ -n "$rm" ] && rm -rf "$to/$rm"
        else abort "ERROR:2: Cant get $get"
        fi
     else abort "ERROR:1: Cant get $get"
     fi
  done
}

set_context() {
   local context huh check="$1" check2="$2" contextback path dir ext try backdir
   if exist "$1"; then context=$(eval_context "$1"); else echo2 "set_context: Invalid line" && return 1; fi
   if defined context; then contextback="$context"; else echo2 "set_context: FATAL ERROR: Cant get context from $1" && return 1; fi
   if ! exist file "$2" || exist folder "$2"; then 
      find "$2" \( -type f -o -type d -o -type l \) 2>/dev/null | while read huh; do
         dir=
         try=
         ext=
         undefined huh && break
         context="$contextback"
         if exist folder "$1" && exist "$1$(string remove "$2" "$huh")"; then
            context=$(eval_context "$1$(string remove "$2" "$huh")")
         else
            while read -r -d/ path || [ -n "$path" ]; do
              if defined path; then
                dir+="/$path"
                if exist folder "$dir"; then
                  context=$(eval_context "$dir")
                  backdir="$dir"
                fi
              fi
            done <<< $(dirname "$1$(string remove "$2" "$huh")")
            ext=${huh##*.}
            if exist file "$huh"; then
               if defined ext; then try=$(find "$backdir" -mindepth 1 -type f -name "*.$ext" | head -n1); fi
               if exist "$try"; then context=$(eval_context "$try"); fi
            fi
         fi
         if undefined context; then context="$contextback"; fi
         ch_con $context "$huh"
      done
   elif exist file "$2"; then
      ch_con $context "$2"
   else
      echo2 "set_context: Invalid line"
   fi
}

eval_context() { ls -Z "$1" | cut -d' ' -f1 | sort | uniq -c | sort -rn | head -n1 | awk '{print $2}'; }

get_context() { ([ -d "$1" ] && ls -Zd "$1" | cut -d' ' -f1 || ls -Z "$1" | cut -d' ' -f1 ) 2>/dev/null; }

eval_perm() { ([ -d "$1" ] && stat -c "%a" "$1"/* || stat -c "%a" "$1" ) 2>/dev/null | sort | uniq -c | sort -rn | head -n1 | awk '{print $2}'; }

eval_user() { ([ -d "$1" ] && stat -c "%u" "$1"/* || stat -c "%u" "$1" ) 2>/dev/null | sort | uniq -c | sort -rn | head -n1 | awk '{print $2}'; }

eval_group() { ([ -d "$1" ] && stat -c "%g" "$1"/* || stat -c "%g" "$1" ) 2>/dev/null | sort | uniq -c | sort -rn | head -n1 | awk '{print $2}'; }

get_all_perm() { stat -c "%u %g %a" "$1" 2>/dev/null; }

eval_all_perm() { echo "$(eval_user "$1") $(eval_group "$1") $(eval_perm "$1")"; }

patch_fstab() {
   #patch_fstab userdata "fileencryption" "encryptable" "FILE"
   local huh line fstab count=0 back stock new
   if exist "$4"; then savestate stock "$4"; else echo2 "patch_fstab: Cant find $4" && return 1; fi
   fstab=$(grep -m1 "$1" "$4")
   if undefined fstab; then echo2 "patch_fstab: Cant get $1 line in $4" && return 1; fi
   back="$fstab"
   huh=$(split_string ',' "$fstab" | grep -m1 "$2")
   fstab=$(string force replace "$huh" "$3" "$fstab")
   if defined back fstab huh && [[ "$fstab" != "$back" ]]; then
      echo2 "patch_fstab: $huh to $3"
      replace "$back" "$fstab" "$4"
      savestate new "$4"
      if [[ "$stock" != "$new" ]]; then echo2 "patch_fstab: Patched $4" && return 0; else return 1; fi
   else
      echo2 "patch_fstab: Abnormal fstab $4" && return 1
   fi
}

import_config() {
    local ugu propc
    while IFS='' read -r ugu || [[ -n "$ugu" ]]; do
          propc=
          test "${ugu#*=}" != "$ugu" && propc=1
          if [[ "$propc" == "1" ]]; then 
              setdefault "$(split_extract = 1 "$ugu" | tr -d ' ')" "$(split_extract = 2 "$ugu")"
          fi   
    done < "$1"
}

import_config_addon() {
    import_config "$addons/$1"
}

import_config_zip() {
    package_extract_file "$1" "$TMP/$(basename "$1")"
    import_config "$TMP/$(basename "$1")"
    rm -f "$TMP/$(basename "$1")"
}

import_info() {
     ( echo >> "$l/info.txt"
       cat "$1" >> "$l/info.txt"
       rm -f "$1"
     ) 2>/dev/null
}

getdefault() {
  grep -m1 "^setdefault $2" "$1" | tr -d '"' | sed s/"setdefault $2 "//
}

savestate() {
    setdefault "$1" "$(md5sum "$2" | awk '{ print $1; }')"
}

startlog() {
    setdefault logpath "$1"
    echo > "$1"
    if exist "$1"; then return 0; else return 1; fi
}

endlog() { unset logpath; }

savelog() {
    if [ -n "$logpath" ]; then
      echo "$1${n}" >> "$logpath"
    fi
    return 0
}

echolog() {
    if [ -n "$logpath" ]; then
      echo "$1${n}" >> "$logpath"
      echo2 "$1"
    fi
    return 0
}

printlog() {
    if [ -n "$logpath" ]; then
      echo "$1${n}" >> "$logpath"
      ui_print "$1"
    fi
    return 0
}

symlink() {
  local file=$(fullpath "$1");
  while [ "$2" ]; do
    ln -sf "$file" "$2";
    shift;
  done;
}

restore_con() {
  restorecon -R "$@";
}

backup_files() {
  while [ "$1" ]; do
    test ! -e "$1.bak" && cp -pf "$1" "$1.bak";
    shift;
  done;
}

restore_files() {
  while [ "$1" ]; do
    mv -f "${1}.bak" "$1";
    shift;
  done;
}

sha3_check() {
  local sum=$(sha3sum $1 | cut -c-40);
  if [ ! "$2" -o $(is_substring $sum "$*") == 1 ]; then
    echo $sum;
  fi;
}

assert() {
  while [ "$1" ]; do
    $1;
    test $? != 0 && abort 'assert failed('"$1"')';
    shift;
  done;
}

split_string() {
    local split delim
    local IFS=$'\n'
    split="$2"
    split=${split//"$1"/$'\n'}
    for delim in $split; do
        echo "$delim"
    done
}

split_cut() {
    local split count delim
    local IFS=$'\n'
    split="$3"
    split=${split//"$1"/$'\n'}
    count=0
    for delim in $split; do
        count=$(($count + 1))
        echo "$delim"
        if [[ "$count" == "$2" ]]; then return; fi;
    done
}

split_extract() {
    local split count delim
    local IFS=$'\n'
    split="$3"
    split=${split//"$1"/$'\n'}
    count=0
    for delim in $split; do
        count=$(($count + 1))
        if [[ "$count" == "$2" ]]; then echo "$delim" && return; fi;
    done
}

checkvar() {
    local splittt13yu
    for splittt13yu in "$@"; do
      eval splittt13yu="\${${splittt13yu}}" 
	  if [ -n "$splittt13yu" ]; then echo "$splittt13yu"; fi;
	done
}

filtervar() {
    local splittt13yu filter717w8jw array61716opr
    array61716opr=( "$@" )
    filter717w8jw=${array61716opr[${#array61716opr[@]} - 1]}
    unset "array61716opr[${#array61716opr[@]}-1]"
    for splittt13yu in "${array61716opr[@]}"; do
		eval splittt13yu="\${${splittt13yu}}" 
        if [ -n "$splittt13yu" ]; then
           if is_substring "$filter717w8jw" "$splittt13yu"; then echo "$splittt13yu"; fi;
    	fi
    done
}

import_bin() {
    cp -pf "$1" "$l"
    if ! chmod +x "$l/$(basename "$1")"; then echo2 " Cant import: $1" && return 1; fi
}

import_bin_addon() {
   import_bin "$addons/$1"
}

import_bin_zip() {
   local result
   package_extract_file "$1" "$TMP/$(basename "$1")"
   import_bin "$TMP/$(basename "$1")"
   result=$?
   rm -f "$TMP/$(basename "$1")"
   return $result
}

setdefault() {
    read -r -d '' "$1" <<< "$2"
    if defined "$1"; then
       if [ "$1" == "permissions" ]; then
          export di_perm_d=$(echo "$permissions" | cut -d: -f1 | tr -d " ")
          export di_perm_f=$(echo "$permissions" | cut -d: -f2 | tr -d " ")
          if ! is_number "$di_perm_d"; then export di_perm_d=0755; fi
          if ! is_number "$di_perm_f"; then export di_perm_f=0777; fi
       fi
       return 0
    else return 1
    fi
}

can_run() {
   local check return
   if [ -f "$1" ]; then
      check=$($1 --help 2>&1)
      [[ -x "$1" && "$check" != *"CANNOT LINK"* ]] && return=0 || return=1
   fi
   if [ -f "$(command -v "$1")" ]; then
      check=$($(command -v "$1") --help 2>&1)
      [[ -x "$(command -v "$1")" && "$check" != *"CANNOT LINK"* ]] && return=0 || return=1
   fi
   if [ -f "$(which "$1")" ]; then
      check=$($(which "$1") --help 2>&1)
      [[ -x "$(which "$1")" && "$check" != *"CANNOT LINK"* ]] && return=0 || return=1
   fi
   [ -z "$return" ] && return 1
   return $return
}

make_overlay() {
   #make_overlay 1 com.android FOLDER result.apk
   local package content result tmp current random priority TMP2
   priority="$1"
   package="$2"
   content="$3"
   result="$4"
   start_tmp
   tmp="$TMP2/overlay"
   echo ">>Overlay Maker 1.0.0"
   if [[ -z "$package" || -z "$content" || -z "$result" || -z "$priority" || ! -d "$content" ]]; then echo " make_overlay: Invalid line " && return; fi
   echo " L: Detected $package..."
   echo " L: With $content..."
   echo " L: Building $(basename "$result")..."
   random=$(echo "$RANDOM" | tr '[0-9]' '[a-z]')
   dynamic_apktool -d "$l/overlay.apk" -o "$tmp" >/dev/null
   if ! exist "$tmp/AndroidManifest.xml"; then echo " CANT setup: make_overlay " && return 1; fi
   replace "overlay.template" "com.$random.dynamic.installer" "$tmp/AndroidManifest.xml"
   replace 'android:targetPackage="android"' 'android:targetPackage="'$package'"' "$tmp/AndroidManifest.xml"
   replace 'android:priority="1"' 'android:priority="'$priority'"' "$tmp/AndroidManifest.xml"
   delete_recursive "$tmp/res"
   current=${PWD}
   cd "$content"
   cp -prf * "$tmp"
   cd "$current"
   dynamic_apktool -sign -r "$tmp" -o "$result" >/dev/null
   if exist "$result"; then echo " L: Success $(basename "$result")"; else echo " make_overlay: Cant compile $(basename "$result")" && return 1; fi
   end_tmp
}

make_overlay_addon() {
   make_overlay "$1" "$2" "$addons/$3" "$4"
}

make_overlay_zip() {
    local result
    delete_recursive "$TMP/00patch"
    package_extract_dir "$3" "$TMP/00patch"
    make_overlay "$1" "$2" "$TMP/00patch" "$4"
    result=$?
    delete_recursive "$TMP/00patch"
    return $result
}

make_zip() {
   local make="$TMP/NewZIP" current=${PWD}
   local restore flag script include include2 type pa output i base head
   local recovery="$make/META-INF/com/google/android"
   local magisk="$make/META-INF/com/google/android/magisk"
   restore=()
   while [[ $# -gt 0 ]]; do
   flag="$1"
   case $flag in
       -script|-s)
       script="$2"
       shift;shift;
       ;;
       -preserve-addons|-pa)
       pa=true
       shift
       ;;
       -type|-t)
       type="$2"
       shift;shift;
       ;;
       -output|-o)
       output="$2"
       shift;shift;
       ;;
       -include|-i)
       include+=("$2")
       shift;shift;
       ;;
       -magisk-include|-mi)
       include2+=("$2")
       shift;shift;
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
   esac
   done
   set -- "${restore[@]}"
   for base in script type output; do
     if undefined $base; then echo2 "make_zip: Invalid line" && return 1; fi
   done
   echo2 '>>> Make ZIP 1.0.0'
   echo2 "-- Making space..."
   delete_recursive "$make"
   package_extract_dir META-INF "$make/META-INF"
   if undefined pa; then delete_recursive "$make/META-INF/addons"; fi
   mkdir -p "$make/META-INF/addons" 2>/dev/null
   for i in "${!include[@]}"; do
      if exist "${include[i]}"; then 
        echo2 "Adding: ${include[i]}"
        cp -pfr "${include[i]}" "$make"
      fi
   done
   for i in "${!include2[@]}"; do
      if exist "${include2[i]}"; then 
        echo2 "Adding:magisk: ${include2[i]}"
        cp -pfr "${include2[i]}" "$magisk"
      fi
   done
   echo2 "-- Making scripts..."
   if is_equal "$type" "recovery"; then
      delete "$recovery/updater-script" 
      if ! is_substring "#MAGISK" "$script"; then echo "#MAGISK" > "$recovery/updater-script"; fi
      echo "$script" >> "$recovery/updater-script" 
   elif is_equal "$type" "magisk"; then
      head=$(string complete_extract 'Dynamic Installer Configs' '#-----------------------' -f "$recovery/updater-script")
      if [ -n "$head" ] && is_substring setdefault "$head"; then echo "$head" > "$recovery/updater-script"; else echo2 "Cant get: Dynamic Installer Configs: updater-script" && return 1; fi
      if ! is_substring "#MAGISK" "$(cat "$recovery/updater-script")"; then echo "#MAGISK" >> "$recovery/updater-script"; fi
      echo "$script" > "$magisk/customize.sh" 
   else
      echo2 "FATAL ERROR: Invalid type" && return 1
   fi
   echo2 "-- Making ZIP..."
   if ! exist "$(dirname "$output")"; then mkdir -p "$(dirname "$output")"; fi
   ( cd "$make" && zip -r "$output" * ) > /dev/null
   cd "$current"
   delete_recursive "$make"
   if is_valid "$output"; then echo2 "-- Done" && return 0; else echo2 "-- ERROR" && return 1; fi
}

dynamic_install_apk() {
   local userlist package f try inst_dir package2 
   local temp_dir temp_dest temp_pack check_split check_package restore flag out nr na
   local ro ra include i file check_overlay
   if ! aapt version >/dev/null; then echo " CANT LOAD AAPT: U cant use dynamic_install_apk " && return 1; fi
   restore=()
   while [[ $# -gt 0 ]]; do
   flag="$1"
   case $flag in
       -o|-output)
       out="$2"
       shift;shift;
       ;;
       -nr|-no-replace)
       nr=true
       shift
       ;;
       -na|-no-add)
       na=true
       shift
       ;;
       -ro|-remove-oat)
       ro=true
       shift
       ;;
       -i|-include)
       include+=("$2")
       shift;shift;
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
   esac
   done
   set -- "${restore[@]}"
   delete "$TMP/userlist.txt"
   delete "$TMP/packages.txt"
   while read userlist; do
       if undefined userlist; then echo2 "dynamic_install_apk: Cant find any apk in $2 " && break; fi
       check_overlay=
       package=
       package=$(apk_package "$userlist")
       check_overlay=$(aapt dump xmlstrings "$userlist" AndroidManifest.xml | grep -w " overlay")
       if undefined check_overlay; then
          echo "$userlist" >> "$TMP/userlist.txt"
          echo "$(basename "$userlist")=$package" >> "$TMP/packages.txt"
       fi
   done <<< $(find "$2" -type f -name "*.apk" 2>/dev/null)
   if ! exist "$TMP/packages.txt" "$TMP/userlist.txt"; then
     #Make false files
     echo > "$TMP/packages.txt" 
     echo > "$TMP/userlist.txt"
   fi
   while read f; do
     if undefined f; then echo2 "dynamic_install_apk: Cant find any apk in $1 " && break; fi
     check_split=
     check_package=
     check_split=$(aapt dump badging "$f" | sed -n "s/.* split='\([^']*\).*$/\1/p")
     if [[ -n "$temp_pack" && -n "$temp_dir" && "$temp_dir" == "$(dirname "$f")" ]]; then
        check_package=$(apk_package "$f")
        if [[ -n "$check_split" && "$check_package" == "$temp_pack" ]]; then
           echo2 "add:split: $(basename "$f") in $temp_dest"
           inject "$f" "$temp_dest" && continue
        fi
     fi
     try=
     inst_dir=$(dirname "$f")
     inst_dir=${inst_dir#$1}
     package=$(apk_package "$f")
     try=$(grep -m1 "$package" "$TMP/packages.txt" | cut -d '=' -f1)
     package2=$(get_file_prop "$TMP/packages.txt" "$try")
     if [[ "$package" == "$package2" ]]; then try=$(grep -m1 "$try" "$TMP/userlist.txt"); fi;
     if [[ -n "$try" && -f "$try" && -z "$check_split" ]]; then
        if [ -n "$nr" ]; then continue; fi
        if [ -n "$out" ]; then try="$out$try"; fi
        temp_pack="$package"
        temp_dir=$(dirname "$f")
        temp_dest=$(dirname "$try")
        if [ -n "$ro" ]; then rm -rf "$temp_dest/oat" 2>/dev/null; fi
        if ! exist "$temp_dest"; then mkdir -p "$temp_dest"; fi
        echo2 "replace: $package in $try"
        cp -pf "$f" "$try"
        if [ -d "$temp_dir/lib" ]; then cp -pfr "$temp_dir/lib" "$temp_dest"; fi
        for i in "${!include[@]}"; do
          if exist "$temp_dir/${include[i]}"; then 
             echo2 "add:extra: ${include[i]}"
             cp -pfr "$temp_dir/${include[i]}" "$temp_dest"
          fi
        done
        set_perm_recursive2 0 0 $di_perm_d $di_perm_f "$temp_dest"
     elif [ -z "$check_split" ]; then
        if [ -n "$na" ]; then continue; fi
        temp_pack="$package"
        temp_dir=$(dirname "$f")
        temp_dest="$2${inst_dir}"
        if [ -n "$out" ]; then temp_dest="$out$temp_dest"; fi
        if [ -n "$ro" ]; then rm -rf "$temp_dest/oat" 2>/dev/null; fi
        echo2 "add: $package in $temp_dest"
        inject "$f" "$temp_dest"
        if [ -d "$temp_dir/lib" ]; then cp -pfr "$temp_dir/lib" "$temp_dest"; fi
        for i in "${!include[@]}"; do
          if exist "$temp_dir/${include[i]}"; then 
             echo2 "add:extra: ${include[i]}"
             cp -pfr "$temp_dir/${include[i]}" "$temp_dest"
          fi
        done
        set_perm_recursive2 0 0 $di_perm_d $di_perm_f "$temp_dest"
     fi
   done <<< $(find "$1" -mindepth 1 -type f -name "*.apk")
}

hex_patch() {
    local xxd 
    if xxd --help >/dev/null; then
       xxd=xxd
    elif /system/bin/xxd --help >/dev/null; then 
       xxd="/system/bin/xxd"
    elif /system/bin/toybox xxd --help >/dev/null; then 
       xxd="/system/bin/toybox xxd"
    elif [ ! -e "/data/adb/magisk/magiskboot" ]; then
       echo "CANT LOAD: xxd or magiskboot" && return 1
    fi
    if ! exist "$3"; then echo "CANT FIND: $3" && return 1; fi
    if $(( $xxd -p "$3" | tr -d \\n | tr -d " " | sed "s/$1/$2/" | $xxd -r -p > "$3.tmp" ) 2>/dev/null ); then
      if hex_check "$2" "$3.tmp"; then
         mv -f "$3.tmp" "$3"
         true
      elif [ -e "/data/adb/magisk/magiskboot" ]; then
         if $(/data/adb/magisk/magiskboot hexpatch "$3" "$1" "$2"); then
           if hex_check "$2" "$3"; then true; else false; fi
         else
           false
         fi   
      else
         false
      fi
    elif [ -e "/data/adb/magisk/magiskboot" ]; then
        if $(/data/adb/magisk/magiskboot hexpatch "$3" "$1" "$2"); then
           if hex_check "$2" "$3"; then true; else false; fi
        else
           false
        fi 
    else
       false  
    fi
}

hex_search() {
    local xxd restore flag
    local after before
    if xxd --help >/dev/null; then
       xxd=xxd
    elif /system/bin/xxd --help >/dev/null; then 
       xxd="/system/bin/xxd"
    elif /system/bin/toybox xxd --help >/dev/null; then 
       xxd="/system/bin/toybox xxd"
    else
       echo " CANT LOAD XXD bin" && return
    fi
    restore=()
    while [[ $# -gt 0 ]]; do
    flag="$1"
    case $flag in
        -include)
        after=$(echo "$2" | grep -Eio "after:[0-9]+" | cut -f2 -d:)
        before=$(echo "$2" | grep -Eio "before:[0-9]+" | cut -f2 -d:)
        if [[ -z "$after" && -z "$before" ]]; then ui_print "hex_search: invalid line" && return; fi
        shift;shift;
        ;;
        *)   
        restore+=("$1")
        shift
        ;;
    esac
    done
    set -- "${restore[@]}"
    if ! exist "$2"; then echo "CANT FIND: $2" && return 1; fi
    if [ -z "$after" ]; then after=0; fi
    if [ -z "$before" ]; then before=0; fi
    ( $xxd -p "$2" | tr -d \\n | tr -d " " | grep -E -o ".{0,${before}}$1.{0,${after}}" ) 2>/dev/null
}

hex_check() {
    local xxd
    if xxd --help >/dev/null; then
       xxd=xxd
    elif /system/bin/xxd --help >/dev/null; then 
       xxd="/system/bin/xxd"
    elif /system/bin/toybox xxd --help >/dev/null; then 
       xxd="/system/bin/toybox xxd"
    else
       echo " CANT LOAD XXD bin" && return
    fi
    if ! exist "$2"; then echo "CANT FIND: $2" && return 1; fi
    if $(( $xxd -p "$2" | tr -d \\n | tr -d " " | grep -q "$1" ) 2>/dev/null ); then true; else false; fi
}

getvalue() {
   local try
   try=$1
   shift 1
   TEMP=`getopt --long -o "$try:" "$@"`
   eval set -- "$TEMP"
   while true ; do
       case "$1" in
           -$try )
               echo "$2"
               shift 2
           ;;
           *)
               break
           ;;
       esac 
   done
}

get_equal_value() {
   local equal i
   equal="$1"
   shift 1
   for i in "$@"
   do
   case $i in
       $equal=*)
       echo "${i#*=}"
       shift
       ;;
       *)
       ;;
   esac
   done
}

get_custom_value() {
   local value key
   value="$1"
   shift 1
   while [[ $# -gt 0 ]]
   do
   key="$1"
   case $key in
       $value)
       echo "$2"
       shift 2
       ;;
       *)  
       shift
       ;;
   esac
   done
}

start_tmp(){
   local random
   random=$(echo "$RANDOM" | tr '[0-9]' '[a-z]')
   TMP2="$TMP/$random"
   kskwiiuwu+=("$TMP2")
   delete_recursive "$TMP2"
   mkdir -p "$TMP2"
}

end_tmp() {
   local i refresh
   delete_recursive "${kskwiiuwu[${#kskwiiuwu[@]} - 1]}"
   unset "kskwiiuwu[${#kskwiiuwu[@]}-1]"
   for i in "${!kskwiiuwu[@]}"; do
      refresh+=("${kskwiiuwu[i]}")
   done
   kskwiiuwu=("${refresh[@]}")
   TMP2=
}

replace() {
   local restore flag r a file try rpl old new load return=0
   restore=()
   while [[ $# -gt 0 ]]; do
   flag="$1"
   case $flag in
       -r|-recursive)
       r=true
       shift
       ;;
       -a|-all-line)
       a=true
       shift
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
   esac
   done
   set -- "${restore[@]}"
   file="$3"
   if ! exist "$file"; then echo "CANT FIND: $file" && return 1; fi
   try="$1"
   rpl="$2"
   if [ -n "$r" ]; then
       while read huh; do
           undefined huh && break
           dir=$(echo "$huh" | cut -f1 -d:)
           if [ -n "$a" ]; then
               load=$(string -f "$dir" replace_line "$try" "$rpl")
           else
               load=$(string -r -f "$dir" replace "$try" "$rpl")
           fi
           if [ -n "$load" ]; then
              if echo "$load" | grep -Fq "$(echo "$rpl" | grep -E "." | head -n1)"; then
                 echo "$load" > "$dir"
                 set_perm2 0 0 $di_perm_f "$dir"
              else echo2 "replace: Cant replace: \"$try\"  \"$rpl\" in $dir" && return=1
              fi
           else echo2 "replace: Nothing to do: $(basename "$dir")"
           fi
       done <<< $(grep -rn "$file" -e "$try")
   else
       if [ -n "$a" ]; then
           load=$(string -f "$file" replace_line "$try" "$rpl")
       else
           load=$(string -r -f "$file" replace "$try" "$rpl")
       fi
       if [ -n "$load" ]; then
          if echo "$load" | grep -Fq "$(echo "$rpl" | grep -E "." | head -n1)"; then
             echo "$load" > "$file"
             set_perm2 0 0 $di_perm_f "$file"
          else echo2 "replace: Cant replace: \"$try\"  \"$rpl\" in $file" && return=1
          fi
       else echo2 "replace: Nothing to do: $(basename "$file")"
       fi
   fi
   return $return
}

getsize() {
   stat -c%s "$1"
}

string() {
   #Multi-tool for Strings by @BlassGO
   local restore flag string array result
   local replace rpl rpl2 rpll rpll2 rm ca c i try try2 huh upper lower et et2 ex ex2 exn exn2 escape
   local al al_add bl bl_add get aln aln_add bln bln_add 
   local p1 p2 r p file back return=0
   local ga gb
   local force
   local fix='s/[]\/$*.^[]/\\&/g'
   restore=()
   while [[ $# -gt 0 ]]; do
   flag="$1"
   case $flag in
       replace)
       rpl+=("$2")
       rpl2+=("$3")
       shift;shift;shift;
       ;;
       replace_line)
       rpll+=("$2")
       rpll2+=("$3")
       shift;shift;shift;
       ;;
       remove)
       rm+=("$2")
       shift;shift;
       ;;
       inside_symbol)
       et="$2"
       et2="$3"
       shift;shift;shift;
       ;;
       inside)
       p1="$2"
       p2="$3"
       shift;shift;shift;
       ;;
       extract)
       ex="$2"
       ex2="$3"
       shift;shift;shift;
       ;;
       complete_extract)
       exn="$2"
       exn2="$3"
       shift;shift;shift;
       ;;
       upper)
       upper=true
       shift
       ;;
       escape)
       escape=true
       shift
       ;;
       lower)
       lower=true
       shift
       ;;
       count)
       c=true
       shift
       ;;
       -al|-after-line)
       al+=("$2")
       al_add+=("$3")
       shift;shift;shift;
       ;;
       -bl|-before-line)
       bl+=("$2")
       bl_add+=("$3")
       shift;shift;shift;
       ;;
       -aln|-after-line-number)
       aln+=("$2")
       aln_add+=("$3")
       shift;shift;shift;
       ;;
       -bln|-before-line-number)
       bln+=("$2")
       bln_add+=("$3")
       shift;shift;shift;
       ;;
       -ga|-get-after)
       ga="$2"
       shift;shift;
       ;;
       -gb|-get-before)
       gb="$2"
       shift;shift;
       ;;
       -r|-recursive)
       r=true
       shift
       ;;
       -p|-pattern)
       p="$2"
       shift;shift;
       ;;
       -f|-file)
       file="$2"
       shift;shift;
       ;;
       force)
       force=true
       shift
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
   esac
   done
   set -- "${restore[@]}"
   array=( "$@" )
   if [ -z "$file" ]; then
      string=${array[${#array[@]} - 1]}
      unset "array[${#array[@]}-1]"
      if [ -z "$string" ]; then echo2 "string: Empty string" && return 1; fi
   else
      if exist file "$file"; then string=$(cat "$file"); else echo2 "string: Cant find $file" && return 1; fi
   fi
   back="$string"
   for i in "${!rpl[@]}"; do
      if [ -n "$r" ]; then
         string="${string//"${rpl[i]}"/"${rpl2[i]}"}"
      else
         string="${string/"${rpl[i]}"/"${rpl2[i]}"}"
      fi
   done
   for i in "${!rpll[@]}"; do
      try=$(echo "${rpll[i]}" | sed -e $fix)
      huh=$(echo "${rpll2[i]}" | sed -e $fix)
      if [ $(echo "${rpll2[i]}" | wc -l) -gt 1 ]; then
        huh=$(echo "$huh" | sed ':a;N;$!ba;s/\n/\\n/g' | sed 's/\$/\\$/g')
      fi
      string=$(echo "$string" | sed -e "/$try/s/.*/$huh/")
   done
   for i in "${!rm[@]}"; do
      if [ -n "$r" ]; then
         string="${string//"${rm[i]}"/}"
      else
         string="${string/"${rm[i]}"/}"
      fi
   done
   if [ -n "$al" ]; then
       for i in "${!al[@]}"; do
          try=$(echo "${al[i]}" | sed -e $fix)
          if [ $(echo "${al_add[i]}" | wc -l) -gt 1 ]; then
             get=$(echo "${al_add[i]}" | sed ':a;N;$!ba;s/\n/\\n/g' | sed 's/\$/\\$/g')
          else
             get="${al_add[i]}"
          fi
          huh=$(echo "${al_add[i]}" | grep "." | head -n1)
          string=$(echo "$string" | sed -e '/'"$try"'/a\'"$get")
          if ! echo "$string" | grep -Fq "$huh"; then return 1; fi
       done
    fi
    if [ -n "$bl" ]; then
       for i in "${!bl[@]}"; do
          try=$(echo "${bl[i]}" | sed -e $fix)
          if [ $(echo "${bl_add[i]}" | wc -l) -gt 1 ]; then
             get=$(echo "${bl_add[i]}" | sed ':a;N;$!ba;s/\n/\\n/g' | sed 's/\$/\\$/g')
          else
             get="${bl_add[i]}"
          fi
          huh=$(echo "${bl_add[i]}" | grep "." | head -n1)
          string=$(echo "$string" | sed -e '/'"$try"'/i\'"$get")
          if ! echo "$string" | grep -Fq "$huh"; then return 1; fi
       done
    fi
    if [ -n "$aln" ]; then
       for i in "${!aln[@]}"; do
          if is_number "${aln[i]}"; then try=$((${aln[i]} + 1)); else echo2 "string: ${aln[i]} inst a number" && return 1; fi
          [ $try -gt $(echo "$string" | wc -l) ] && string="${string}${n}"
          if [ $(echo "${aln_add[i]}" | wc -l) -gt 1 ]; then
             get=$(echo "${aln_add[i]}" | sed ':a;N;$!ba;s/\n/\\n/g' | sed 's/\$/\\$/g')
          else
             get="${aln_add[i]}"
          fi
          huh=$(echo "${aln_add[i]}" | grep "." | head -n1)
          string=$(echo "$string" | sed -e ${try}i'\'"$get")
          if ! echo "$string" | grep -Fq "$huh"; then return 1; fi
       done
    fi
    if [ -n "$bln" ]; then
       for i in "${!bln[@]}"; do
          if is_number "${bln[i]}"; then try=${bln[i]}; else echo2 "string: ${bln[i]} inst a number" && return 1; fi
          if [ $(echo "${bln_add[i]}" | wc -l) -gt 1 ]; then
             get=$(echo "${bln_add[i]}" | sed ':a;N;$!ba;s/\n/\\n/g' | sed 's/\$/\\$/g')
          else
             get="${bln_add[i]}"
          fi
          huh=$(echo "${bln_add[i]}" | grep "." | head -n1)
          string=$(echo "$string" | sed -e ${try}i'\'"$get")
          if ! echo "$string" | grep -Fq "$huh"; then return 1; fi
       done
    fi
   if [ -n "$et" ]; then
      try=$(echo "$string" | awk -F "$et|$et2" '{print $2}')
      if [ -n "$try" ]; then string="$try"; fi
   fi
   if [ -n "$p1" ]; then
      try=${string#*"$p1"}
      try=${try%"$p2"*}
      if [[ -n "$try" && $(echo "$try" | wc -l) == 1 ]]; then string="$try"; fi
   fi
   if [ -n "$ga" ]; then
      try=${string#*"$ga"}
      if [[ -n "$try" && $(echo "$try" | wc -l) == 1 ]]; then string="$try"; fi
   fi
   if [ -n "$gb" ]; then
      try=${string%"$gb"*}
      if [[ -n "$try" && $(echo "$try" | wc -l) == 1 ]]; then string="$try"; fi
   fi
   if [ -n "$ex" ]; then
      try=
      huh=
      try=$(echo "$ex" | sed -e $fix)
      huh=$(echo "$ex2" | sed -e $fix)
      if [ -z "$r" ]; then
         try=$(echo "$string" | sed -n "/$try/,/$huh/{p; /$huh/q}" | sed -e '1d;$d')
         if defined p && ! echo "$try" | grep -Fq "$p"; then try=; fi
      else
         #Recursive analysis
         if [ -z "$p" ]; then
            try=$(echo "$string" | sed -n "/$try/,/$huh/{ /$try/! { /$huh/! p } }")
         else
            try=$(echo "$string" | sed -n "/$try/,/$huh/p" | sed -e "/$try/s/.*/\n\n/" | sed -e "/$huh/s/.*/\n\n/" | awk -v RS='' "/$p/")
         fi
      fi
      if [ -n "$try" ]; then string="$try"; fi
   fi
   if [ -n "$exn" ]; then
      try=
      huh=
      try=$(echo "$exn" | sed -e $fix)
      huh=$(echo "$exn2" | sed -e $fix)
      if [ -z "$r" ]; then
         try=$(echo "$string" | sed -n "/$try/,/$huh/{p; /$huh/q}")
         if defined p && ! echo "$try" | grep -Fq "$p"; then try=; fi
      else
         #Recursive analysis
         if [ -z "$p" ]; then
            try=$(echo "$string" | sed -n "/$try/,/$huh/p")
         else
            try=$(echo "$string" | sed -n "/$try/,/$huh/p" | sed -e '/'"$try"'/i\'${n}${n} | sed -e '/'"$huh"'/a\'${n}${n} | awk -v RS='' "/$p/")
         fi
      fi
      if ! echo "$try" | head -n1 | grep -Fq "$exn"; then return 1; fi
      if ! echo "$try" | tail -n1 | grep -Fq "$exn2"; then return 1; fi
      if [ -n "$try" ]; then string="$try"; fi
   fi
   if [[ -n "$upper" && -z "$lower" ]]; then
      string=$(echo "$string" | tr '[:lower:]' '[:upper:]')
   elif [[ -z "$upper" && -n "$lower" ]]; then
      string=$(echo "$string" | tr '[:upper:]' '[:lower:]')
   fi
   if [ -n "$escape" ]; then
      string=$(echo "$string" | sed -e $fix)
   fi
   if [[ -z "$force" && -z "$c" && -z "$escape" && -z "$upper" && -z "$lower" && -z "$exn" && "$string" == "$back" ]]; then return 1; fi
   if [ -n "$c" ]; then
      echo "${#string}"
   else
      echo "$string"
   fi
   return $return
}

chooseport() {
  # Keycheck binary by someone755 @Github
  local error=0
  while true; do
    sleep 1
    keycheck
    local SEL=$?
    if [ $SEL -eq 42 ]; then
      return 0
    elif [ $SEL -eq 41 ]; then
      return 1
    else
      abort " ERROR: keycheck "
    fi
  done
}

find_block() {
   local BLOCK DEV DEVICE DEVNAME PARTNAME UEVENT
   local restore flag express time t=5
   restore=()
   while [[ $# -gt 0 ]]; do
     flag="$1"
     case $flag in
         -e|-express)
         express=true
         shift
         ;;
         -t|-time)
         time="$2"
         shift;shift;
         ;;
         *)   
         restore+=("$1")
         shift
         ;;
     esac
   done
   set -- "${restore[@]}"
   if [ -n "$time" ] && ! is_number "$time"; then echo2 "find_block: Invalid line" && return 1
   elif [ -n "$time" ] && is_number "$time"; then t="$time"
   fi
   for BLOCK in "$@"; do
     DEVICE=`timeout -t $t find /dev/block \( -type b -o -type c -o -type l \) -iname $BLOCK -o -iname $BLOCK$slot | head -n 1` 2>/dev/null
     if [ ! -z $DEVICE ]; then
       readlink -f $DEVICE
       return 0
     fi
   done
   if [ -z "$express" ]; then
      # Fallback by parsing sysfs uevents
      SECONDS=0
      for UEVENT in /sys/dev/block/*/uevent; do
        if [[ -n "$time" && "$time" -le "$SECONDS" ]]; then break; fi
        DEVNAME=`grep_prop DEVNAME $UEVENT`
        PARTNAME=`grep_prop PARTNAME $UEVENT`
        for BLOCK in "$@"; do
          if [[ "$(toupper $BLOCK)" == "$(toupper $PARTNAME)" || "$(toupper $BLOCK$slot)" == "$(toupper $PARTNAME)" ]]; then
            echo /dev/block/$DEVNAME
            return 0
          fi
        done
      done
   fi
   # Look just in /dev in case we're dealing with MTD/NAND without /dev/block devices/links
   for DEV in "$@"; do
     DEVICE=`timeout -t $t find /dev \( -type b -o -type c -o -type l \) -maxdepth 1 -iname $DEV -o -iname $DEV$slot | head -n 1` 2>/dev/null
     if [ ! -z $DEVICE ]; then
       readlink -f $DEVICE
       return 0
     fi
   done
   return 1
}

toupper() {
  echo "$@" | tr '[:lower:]' '[:upper:]'
}

grep_cmdline() {
  local REGEX="s/^$1=//p"
  cat /proc/cmdline | tr '[:space:]' '\n' | sed -n "$REGEX" 2>/dev/null
}

grep_prop() {
  local REGEX="s/^$1=//p"
  shift
  local FILES=$@
  [ -z "$FILES" ] && FILES='/system/build.prop'
  cat $FILES | dos2unix | sed -n "$REGEX" 2>/dev/null | head -n 1
}

try_mount() {
  local try basetry part result
  local restore flag rw ro re name file LOOP express
  restore=()
  while [[ $# -gt 0 ]]; do
  flag="$1"
  case $flag in
       -rw|-read-write)
       rw=true
       shift
       ;;
       -ro|-read-only)
       ro=true
       shift
       ;;
       -re|-remount)
       re=true
       shift
       ;;
       -e|-express)
       express=true
       shift
       ;;
       -n|-name)
       name="$2"
       shift;shift;
       ;;
       -f|-file)
       file="$2"
       shift;shift;
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
   esac
  done
  set -- "${restore[@]}"
  #Ensure root space
  mount -o rw,remount -t auto / 2>/dev/null
  if undefined ro rw; then rw=true && ro=true; fi
  for try in "$@"; do
     if [ -z "$name" ]; then basetry=$(split_extract / 1 "$try"); else basetry="$name"; fi
     if [[ -z "$file" && -z "$express" ]]; then part=$(find_block "$basetry")
     elif [[ -z "$file" && -n "$express" ]]; then part=$(find_block -e "$basetry")
     else
        basetry="No needed"
        if [ ! -e "$file" ]; then echo2 " CANT FIND: $file" && return 1; fi
        if can_run losetup2; then
           if [ -n "$name" ]; then
              start_loop "$name" "$file" 2>/dev/null
              part="$LOOP"
           elif [ -b "$file" ]; then
              part="$file"
           else
              part=$(losetup2 -Pf --show "$file" 2>/dev/null)
           fi
           if [ -z "$part" ]; then echo2 " Cant loop: $file" && return 1
           elif losetup2 -a | grep -q "$part"; then
             echo2 " Looping: $part"
             contains_array "$try" "${all_looped[@]}" || all_looped+=("$try")
             contains_array "$part" "${all_looped_loop[@]}" || all_looped_loop+=("$part")
           else
             echo2 " Cant loop: $file" && return 1
           fi
        else
           echo2 "Unsupported: $(bin_info losetup2)" && return 1
        fi
     fi
     if [[ -n "$part" && -n "$basetry" ]]; then
         [ -n "$rw" ] && blockdev --setrw "$part" >/dev/null 2>&1
         setup_mountpoint "$try"
         if [ -n "$re" ]; then [[ -n "$name" && -d "/$name" ]] && unmount "/$name"; unmount "$try"; fi
         if ! is_mounted "$try" || [ -n "$file" ]; then
            if [ -n "$rw" ]; then
               if $(mount -w "$try" 2>/dev/null); then
                 echo2 " Mounting:1: $part $try" && result=0
               elif $(mount -w "$part" "$try" 2>/dev/null); then
                 echo2 " Mounting:2: $part $try" && result=0
               elif $(mount -w -t auto "$part" "$try" 2>/dev/null); then
                 echo2 " Mounting:3: $part $try" && result=0
               elif $(mount -w -t ext4 "$part" "$try" 2>/dev/null); then
                 echo2 " Mounting:4: $part $try" && result=0
               elif $(mount -o rw,remount -t auto "$try" 2>/dev/null); then
                 echo2 " Mounting:5: $part $try" && result=0
               elif $(mount -o rw,remount -t auto "$part" "$try" 2>/dev/null); then
                 echo2 " Mounting:6: $part $try" && result=0
               else
                 if ! is_mounted "$try"; then echo2 " CANT MOUNT: $try as RW" && result=1; fi
               fi
            fi
            if [ -n "$ro" ] && ! is_mounted "$try"; then
               if $(mount -r "$try" 2>/dev/null); then
                 echo2 " Mounting:ro:1: $part $try" && result=0
               elif $(mount -r "$part" "$try" 2>/dev/null); then
                 echo2 " Mounting:ro:2: $part $try" && result=0
               else
                 if ! is_mounted "$try"; then echo2 " CANT MOUNT: $try as RO" && result=1; fi;
               fi
            fi
         else
            if [ -n "$rw" ] && $(mount -o rw,remount -t auto "$try" 2>/dev/null); then
                echo2 " Mounting:auto:1: $part $try" && result=0
            elif [ -n "$rw" ] && $(mount -o rw,remount -t auto "$part" "$try" 2>/dev/null); then
                echo2 " Mounting:auto:2: $part $try" && result=0
            elif [ -n "$ro" ] && $(mount -o ro,remount -t auto "$try" 2>/dev/null); then
                echo2 " Mounting:auto:ro:1: $part $try" && result=0
            elif [ -n "$ro" ] && $(mount -o ro,remount -t auto "$part" "$try" 2>/dev/null); then
                echo2 " Mounting:auto:ro:2: $part $try" && result=0
            else
                echo2 " Already mounted: $try" && result=1
            fi
         fi
     else
        echo2 "Attempted with: $basetry $part"
        if [ -n "$re" ]; then [[ -n "$name" && -d "/$name" ]] && unmount "/$name"; unmount "$try"; fi
        if ! is_mounted "$try"; then
           setup_mountpoint "$try"
           if [ -n "$rw" ] && $(mount -w "$try" 2>/dev/null); then
              echo2 " Mounting:noblock:rw: $try" && result=0
           elif [ -n "$ro" ] && $(mount -r "$try" 2>/dev/null); then
              echo2 " Mounting:noblock:ro: $try" && result=0
           else
              if ! is_mounted "$try"; then echo2 " CANT MOUNT: $try" && result=1; fi;
           fi
        else
            if [ -n "$rw" ] && $(mount -o rw,remount -t auto "$try" 2>/dev/null); then
                echo2 " Mounting:auto:noblock:1: $try" && result=0
            elif [ -n "$ro" ] && $(mount -o ro,remount -t auto "$try" 2>/dev/null); then
                echo2 " Mounting:auto:noblock:ro:1: $try" && result=0
            else
                echo2 " Already mounted: $try" && result=1
            fi
        fi
     fi
     if is_mounted "$try"; then contains_array "$try" "${all_umount[@]}" || all_umount+=("$try"); else result=1; fi
  done
  return $result
}

run_wait() {
    local pid count time="$1"
    if ! is_number "$time"; then echo "run_wait: Invalid Line" && return 1; fi
    if exist file "$2"; then chmod +x "$2"; fi
    shift >/dev/null 2>&1 
    $@ & pid=$! count=0
    while kill -0 $pid >/dev/null 2>&1 ; do
        read -t 1 >/dev/null 2>&1 
        count=$(( $count + 1 ))
        if [ $count -ge $time ]; then
            kill $pid >/dev/null 2>&1 && break
        fi
    done
    wait $pid
    return $?
}

run_jar() {
    local dalvikvm file main 
    #Inspired in the osm0sis method
    if dalvikvm -showversion >/dev/null; then
       dalvikvm=dalvikvm
    elif /system/bin/dalvikvm -showversion >/dev/null; then 
       dalvikvm=/system/bin/dalvikvm
    else
       echo "CANT LOAD DALVIKVM " && return 1
    fi
    file="$1"
    main=$(unzip -qp "$file" "META-INF/MANIFEST.MF" | grep -m1 "^Main-Class:" | cut -f2 -d: | tr -d " " | dos2unix)
    if [ -z "$main" ]; then
       echo "Cant get main: $file " && return 1
    fi
    shift 1
    $dalvikvm -Djava.io.tmpdir=. -Xnodex2oat -Xnoimage-dex2oat -cp "$file" $main "$@" 2>/dev/null \ || $dalvikvm -Djava.io.tmpdir=. -Xnoimage-dex2oat -cp "$file" $main "$@"
}

run_jar_addon() {
    local file
    file="$1"
    shift 1
    run_jar "$addons/$file" "$@"
}

run_jar_zip() {
    local file result
    file="$1"
    shift 1
    package_extract_file "$file" "$TMP/$(basename "$file")"
    run_jar "$TMP/$(basename "$file")" "$@"
    result=$?
    rm -f "$TMP/$(basename "$file")"
    return $result
}

run_jar_class() {
    local dalvikvm file main class
    #Inspired in the osm0sis method
    if dalvikvm -showversion >/dev/null; then
       dalvikvm=dalvikvm
    elif /system/bin/dalvikvm -showversion >/dev/null; then 
       dalvikvm=/system/bin/dalvikvm
    else
       echo "CANT LOAD DALVIKVM " && return 1
    fi
    file="$1"
    class="$2"
    if [ -z "$class" ]; then
       echo "Class undefined: $file " && return 1
    fi
    shift 2
    $dalvikvm -Djava.io.tmpdir=. -Xnodex2oat -Xnoimage-dex2oat -cp "$file" $class "$@" 2>/dev/null \ || $dalvikvm -Djava.io.tmpdir=. -Xnoimage-dex2oat -cp "$file" $class "$@"
}

run_jar_class_addon() {
    local file
    file="$1"
    shift 1
    run_jar_class "$addons/$file" "$@"
}

run_jar_class_zip() {
    local file result
    file="$1"
    shift 1
    package_extract_file "$file" "$TMP/$(basename "$file")"
    run_jar_class "$TMP/$(basename "$file")" "$@"
    result=$?
    rm -f "$TMP/$(basename "$file")"
    return $result
}

apktool() {
   if [ ! -e /system/framework/framework-res.apk ]; then auto_mount_partitions; fi
   cp -f /system/framework/framework-res.apk "$TMP/1.apk"
   if [ ! -e "$l/apktool.jar" ]; then ui_print " Cant find apktool.jar " && return 1; fi
   run_jar "$l/apktool.jar" --aapt "$l/aapt" -p "$TMP" "$@"
}

sign() {
   if [ ! -e "$l/zipsigner.jar" ]; then ui_print " Cant find zipsigner.jar" && return 1; fi
   run_jar "$l/zipsigner.jar" "$@"
}

decode_xml() {
   local result="$TMP/$RANDOM.xml" return=0
   if [ ! -e "$l/axml.jar" ]; then ui_print " Cant find axml.jar" && return 1; fi
   if ! is_substring "ArrayIndexOutOfBoundsException" "$(run_jar "$l/axml.jar" -d "$1" "$result")" && is_valid "$result"; then
      if [ -n "$2" ]; then copy "$result" "$2" || return=1
      else copy "$result" "$1" || return=1
      fi
   else return=1
   fi
   delete "$result"
   return $return
}

encode_xml() {
   local result="$TMP/$RANDOM.xml" return=0
   if [ ! -e "$l/axml.jar" ]; then ui_print " Cant find axml.jar" && return 1; fi
   if ! is_substring "ArrayIndexOutOfBoundsException" "$(run_jar "$l/axml.jar" -e "$1" "$result")" && is_valid "$result"; then
      if [ -n "$2" ]; then copy "$result" "$2" || return=1
      else copy "$result" "$1" || return=1
      fi
   else return=1
   fi
   delete "$result"
   return $return
}

xml_kit() {
   #XML Tool kit for Dynamic Installer by @BlassGO
   local restore flag
   local xml open close cv code try back i
   local custom1 eq1 eq2 in1 in2
   local native native2 revert result result2 backdir
   local value_1 value_2 content_1 content_2 tag_1 tag_2 in remove print only add al1 al2 bl1 bl2 nas inside
   restore=()
   while [[ $# -gt 0 ]]; do
   flag="$1"
   case $flag in
       -open|-o)
       open+=("$2")
       close+=("$3")
       if [[ -z "$2" || -z "$3" ]]; then echo2 "xml_kit: Invalid line" && return 1; fi
       shift;shift;shift;
       ;;
       -change-value)
       cv="$2"
       value_1="$2"
       value_2="$3"
       if [[ -z "$2" || -z "$3" ]]; then echo2 "xml_kit: Invalid line" && return 1; fi
       shift;shift;shift;
       ;;
       -change-content)
       cv="$2"
       content_1="$2"
       content_2="$3"
       if [[ -z "$2" || -z "$3" ]]; then echo2 "xml_kit: Invalid line" && return 1; fi
       shift;shift;shift;
       ;;
       -change-tag)
       cv="$2"
       tag_1="$2"
       tag_2="$3"
       if [[ -z "$2" || -z "$3" ]]; then echo2 "xml_kit: Invalid line" && return 1; fi
       shift;shift;shift;
       ;;
       -add)
       add="$2"
       if [ -z "$2" ]; then echo2 "xml_kit: Invalid line" && return 1; fi
       shift;shift;
       ;;
       -add-inside)
       inside="$2"
       if [ -z "$2" ]; then echo2 "xml_kit: Invalid line" && return 1; fi
       shift;shift;
       ;;
       -after-line|-al)
       al1="$2"
       al2="$3"
       if [[ -z "$2" || -z "$3" ]]; then echo2 "xml_kit: Invalid line" && return 1; fi
       shift;shift;shift;
       ;;
       -before-line|-bl)
       bl1="$2"
       bl2="$3"
       if [[ -z "$2" || -z "$3" ]]; then echo2 "xml_kit: Invalid line" && return 1; fi
       shift;shift;shift;
       ;;
       -remove|-rm)
       remove=true
       shift
       ;;
       -print)
       print=true
       shift
       ;;
       -only-result|-or)
       only=true
       shift
       ;;
       -no-auto-spaces|-nas)
       nas=true
       shift
       ;;
       -in)
       in="$2"
       if [ -z "$2" ]; then echo2 "xml_kit: Invalid line" && return 1; fi
       shift;shift;
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
   esac
   done
   set -- "${restore[@]}"
   array=( "$@" )
   xml=${array[${#array[@]} - 1]}
   if exist "$xml"; then backdir="$xml" && xml=$(cat "$xml") && back="$xml"; else echo2 "xml_kit: Invalid line" && return 1; fi
   unset "array[${#array[@]}-1]"
   [ -n "$in" ] && cv="$in"
   for i in "${!open[@]}"; do
      if [ -z "$xml" ]; then echo2 "xml_kit: Some error in the XML logic" && return 1; fi
      if is_substring '/>' "${close[i]}" || is_substring '</' "${close[i]}"; then custom1=true; fi
      eq1=$(echo "$xml" | grep -Fc "${open[i]}")
      eq2=$(echo "$xml" | grep -Fc "${close[i]}")
      #in1=$(echo "$xml" | grep -Fn "${open[i]}" | cut -d: -f1 | head -n1)
      #in2=$(echo "$xml" | grep -Fn "${close[i]}" | cut -d: -f1 | tail -n1)
      if [[ -z "$custom1" && $eq1 != $eq2 ]]; then
         echo2 "xml_kit: Invalid XML pattern: ${open[i]} ${close[i]}" && return 1
      elif [ $eq1 == 0 ]; then
         echo2 "xml_kit: No results for: \"${open[i]}\" \"${close[i]}\" " && return 1
      fi
      if [ -z "$cv" ] && ! is_substring "${close[i]}" "$(echo "$xml" 2>/dev/null | grep -Fm1 "${open[i]}")"; then
         xml=$(string -r complete_extract "${open[i]}" "${close[i]}" "$xml")
      elif is_substring "${close[i]}" "$(echo "$xml" 2>/dev/null | grep -Fm1 "${open[i]}")"; then
         xml=$(echo "$xml" | grep -E ".*${open[i]}.*${close[i]}.*")
      elif [ -n "$cv" ]; then
         xml=$(string -p "$cv" -r complete_extract "${open[i]}" "${close[i]}" "$xml")
      else
         echo2 "xml_kit: Unsupported format" && return 1
      fi
      if ! is_substring "${open[i]}" "$(echo "$xml" 2>/dev/null | head -n1)" || ! is_substring "${close[i]}" "$(echo "$xml" 2>/dev/null | tail -n1)"; then echo2 "xml_kit: Cant get valid result: \"${open[i]}\" \"${close[i]}\" " && return 1; fi
      revert+=("$xml")
   done
   if [ -n "$add" ]; then
      native=$(echo "$xml" | tail -n1)
      if [ -z "$nas" ]; then
         native2=$(echo "$native" | awk '{print $1;}')
         native2=$(string -get-before "$native2" "$native")
         add=$(echo "$add" | sed -e "s/^/$native2/")
      fi
      result=$(string -after-line "$native" "$add" "$xml")
      if [ -z "$result" ]; then echo2 "xml_kit: Cant add content in $native" && return 1; fi
      xml="$result"
   fi
   if [ -n "$inside" ]; then
      native=$(echo "$xml" | grep -E "." | tail -n2 | head -n1)
      if [ -z "$nas" ]; then
         native2=$(echo "$native" | awk '{print $1;}')
         native2=$(string -get-before "$native2" "$native")
         inside=$(echo "$inside" | sed -e "s/^/$native2/")
      fi
      native=$(echo "$xml" | grep -E "." | tail -n1)
      result=$(string -before-line "$native" "$inside" "$xml")
      if [ -z "$result" ]; then echo2 "xml_kit: Cant add content in $native" && return 1; fi
      xml="$result"
   fi
   if [ -n "$al1" ]; then
      native=$(echo "$xml" | grep -Fm1 "$al1")
      if [ -z "$nas" ]; then
         native2=$(echo "$native" | awk '{print $1;}')
         native2=$(string -get-before "$native2" "$native")
         al2=$(echo "$al2" | sed -e "s/^/$native2/")
      fi
      result=$(string -after-line "$native" "$al2" "$xml")
      if [ -z "$result" ]; then echo2 "xml_kit: Cant add content in $native" && return 1; fi
      xml="$result"
   fi
   if [ -n "$bl1" ]; then
      native=$(echo "$xml" | grep -Fm1 "$bl1")
      if [ -z "$nas" ]; then
         native2=$(echo "$native" | awk '{print $1;}')
         native2=$(string -get-before "$native2" "$native")
         bl2=$(echo "$bl2" | sed -e "s/^/$native2/")
      fi
      result=$(string -before-line "$native" "$bl2" "$xml")
      if [ -z "$result" ]; then echo2 "xml_kit: Cant add content in $native" && return 1; fi
      xml="$result"
   fi
   if [ -n "$value_1" ]; then
      native=$(echo "$xml" | grep -E -om1 "$value_1.*")
      native2=$(string inside_symbol '="' '"' "$native")
      if [[ -z "$native2" || $(echo "$native2" | wc -l) -gt 2 ]]; then echo2 "xml_kit: Cant get value of: $value_1" && return 1; fi
      result=$(string force replace "$native2" "$value_2" "$native")
      result=$(string replace "$native" "$result" "$xml")
      if [ -z "$result" ]; then echo2 "xml_kit: No changes: Probably the new value for \"$value_1\" already exist" && return 1; fi
      xml="$result"
   fi
   if [ -n "$content_1" ]; then
      native=$(echo "$xml" | grep -Fm1 "$content_1")
      if [[ -z "$native" || $(echo "$native" | wc -l) -gt 2 ]]; then echo2 "xml_kit: Cant get: $content_1" && return 1; fi
      result=$(string force replace "$content_1" "$content_2" "$native")
      result=$(string replace "$native" "$result" "$xml")
      if [ -z "$result" ]; then echo2 "xml_kit: No changes: Probably the changes already exist" && return 1; fi
      xml="$result"
   fi
   if [ -n "$tag_1" ]; then
      native=$(echo "$xml" | grep -Fm1 "${tag_1}>")
      native2=$(string inside "${tag_1}>" "</${tag_1}" "$native")
      if [[ -z "$native2" || $(echo "$native2" | wc -l) -gt 2 ]]; then echo2 "xml_kit: Cant get value of tag: $tag_1" && return 1; fi
      result=$(string force replace "$native2" "$tag_2" "$native")
      result=$(string replace "$native" "$result" "$xml")
      if [ -z "$result" ]; then echo2 "xml_kit: No changes: Probably the $tag_1 already has the new value" && return 1; fi
      xml="$result"
   fi
   if [ -n "$remove" ]; then
      result=" "
   fi
   if [ -n "$result" ]; then
      for i in $(echo ${!revert[@]} | rev); do
         result2=$(string replace "${revert[i]}" "$result" "${revert[i - 1]}")
         [ -n "$result2" ] && result="$result2" || break
      done
      if ! is_text "$result"; then echo2 "xml_kit: Some error in XML remaking" && return 1; fi
      if [ -z "$only" ]; then result=$(string replace "${revert[0]}" "$result" "$back"); fi
      if ! is_text "$result"; then echo2 "xml_kit: Some error in XML remaking" && return 1; fi
   fi
   if [ -n "$result" ]; then
      if [ -z "$print" ]; then
         echo "$result" > "$backdir"
         if is_valid "$backdir"; then set_perm2 0 0 $di_perm_f "$backdir"
         else echo2 "xml_kit: Cant write $backdir" && return 1
         fi
      else echo "$result"
      fi
   elif [[ -n "$xml" && "$xml" != "$back" ]]; then echo "$xml"
   else echo2 "xml_kit: Unknown problem" && return 1
   fi
}

dynamic_apktool() {
   #Dynamic Apktool for Dynamic Installer by BlassGO
   local file fullname filename filedir outdir folder outfile sign zipa add alladd move fw check out
   local flag current restore ext ps manifest min max try
   restore=()
   while [[ $# -gt 0 ]]; do
   flag="$1"
   case $flag in
       -d|-decompile)
       file="$2"
       fullname=$(basename "$2")
       filename=${fullname%.*}
       filedir=$(dirname "$2")
       outdir="$filedir/$filename"
       shift;shift;
       ;;
       -r|-recompile)
       folder="$2"
       outfile=$(cat "$folder/apktool.yml" | grep -m1 "FileName:" | tr -d " " | cut -f2 -d:)
       ext=${outfile##*.}
       shift;shift;
       ;;
       -s|-sign)
       sign=true
       shift
       ;;
       -z|-zipalign)
       zipa=true
       shift
       ;;
       -a|-add)
       add=true
       alladd+=$(echo "$2:")
       shift;shift;
       ;;
       -o|-output)
       move="$2"
       shift;shift;
       ;;
       -c|-command)
       command="$2"
       shift;shift;
       ;;
       -ps|-preserve-signature)
       ps=true
       shift
       ;;
       -f|-framework)
       fw="$2"
       shift;shift;
       ;;
       -im|-include-manifest)
       manifest=true
       shift
       ;;
       -min-sdk)
       min="$2"
       shift;shift;
       ;;
       -max-sdk)
       max="$2"
       shift;shift;
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
   esac
   done
   set -- "${restore[@]}"
   if [ ! -e /system/build.prop ]; then auto_mount_partitions; fi
   if [ ! -e "$l/apktool.jar" ]; then ui_print " Cant find apktool.jar " && return 1; fi
   if [ ! -e "$l/zipsigner.jar" ]; then ui_print " Cant find zipsigner.jar" && return 1; fi
   if [ ! -e "$l/axml.jar" ]; then ui_print " Cant find axml.jar" && return 1; fi
   echo ">>Dynamic Apktool 1.2.0"
   if [[ -n "$file" && -z "$folder" && -z "$zipa" && -z "$sign" ]]; then
      if [ -n "$fw" ]; then cp -f "$fw" "$TMP/1.apk"; else cp -f /system/framework/framework-res.apk "$TMP/1.apk"; fi
      if [ -n "$move" ]; then
         rm -rf "$move" 2>/dev/null
         echo " L: Decompiling $fullname... "
         echo " L: Please wait..."
         if ! run_jar "$l/apktool.jar" --aapt "$l/aapt" --no-res -p "$TMP" $command d "$file" -o "$move" >/dev/null 2>&1; then echo " ERROR: Cant decompile $fullname" && return 1; fi
         echo " L: Checking results..."
         if [ ! -d "$move" ]; then echo "ERROR: Decompiling $fullname" && return 1; fi
         if [ -n "$add" ]; then
            local IFS=$'\n'
            for add in $(split_string : "$alladd"); do
              echo " L: Adding $(basename "$add")"
              cp -rf "$add" "$move"
            done
         fi
      else
         rm -rf "$outdir" 2>/dev/null
         echo " L: Decompiling $fullname..."
         echo " L: Please wait..."
         if ! run_jar "$l/apktool.jar" --aapt "$l/aapt" --no-res -p "$TMP" $command d "$file" -o "$outdir" >/dev/null 2>&1; then echo " ERROR: Cant decompile $fullname" && return 1; fi
         echo " L: Checking results..."
         if [ ! -d "$outdir" ]; then echo "ERROR: Decompiling $fullname" && return 1; fi
         if [ -n "$add" ]; then
            local IFS=$'\n'
            for add in $(split_string : "$alladd"); do
              echo " L: Adding $(basename "$add")"
              cp -rf "$add" "$outdir"
            done
         fi
      fi
      echo " L: Success "
   elif [[ -z "$file" && -n "$folder" ]]; then
         if [ -n "$fw" ]; then cp -f "$fw" "$TMP/1.apk"; else cp -f /system/framework/framework-res.apk "$TMP/1.apk"; fi
         rm -f "$folder/try.apk" 2>/dev/null
         rm -rf "$folder/dist" 2>/dev/null
         echo " L: Recompiling $(basename "$folder")... "
         if [[ -n "$min" || -n "$max" ]]; then
            if decode_xml "$folder/AndroidManifest.xml"; then
               if [ -n "$min" ]; then
                  xml_kit -open '<manifest' '</manifest>' -open '<uses-sdk' '>' -change-value android:minSdkVersion $min "$folder/AndroidManifest.xml"
                  min=$(sed -n 's/.*android:minSdkVersion="\([^"]*\).*$/\1/p' "$folder/AndroidManifest.xml")
                  [ -n "$min" ] && echo " L: Min-sdk: $min"
               fi
               if [ -n "$max" ]; then
                  xml_kit -open '<manifest' '</manifest>' -open '<uses-sdk' '>' -change-value android:maxSdkVersion $max "$folder/AndroidManifest.xml"
                  max=$(sed -n 's/.*android:maxSdkVersion="\([^"]*\).*$/\1/p' "$folder/AndroidManifest.xml")
                  [ -n "$max" ] && echo " L: Max-sdk: $max"
               fi
               encode_xml "$folder/AndroidManifest.xml"
            fi
         fi
         if [ -n "$manifest" ]; then
            echo " L: Including AndroidManifest.xml"
            cp -f "$folder/AndroidManifest.xml" "$folder/original/AndroidManifest.xml"
         fi
         if [ -z "$ps" ]; then
            echo " L: Using all changes..."
            echo " L: Please wait..."
            run_jar "$l/apktool.jar" --aapt "$l/aapt" -p "$TMP" -f $command b "$folder" -o "$folder/try.apk" >/dev/null 2>&1
         else
            echo " L: Saving signature..."
            echo " L: Please wait..."
            run_jar "$l/apktool.jar" --aapt "$l/aapt" -p "$TMP" -f $command --copy-original b "$folder" -o "$folder/try.apk" >/dev/null 2>&1
         fi
         if [ ! -e "$folder/try.apk" ]; then echo "ERROR: Compiling $outfile" && return 1; fi
         if [ -n "$add" ]; then
            local IFS=$'\n'
            current=${PWD}
            for add in $(split_string : "$alladd"); do
                echo " L: Adding $(basename "$add")"
                cd "$(dirname "$add")"
                zip -ur "$folder/try.apk" "$(basename "$add")" >/dev/null
            done
            cd "$current"
         fi
         if [ -n "$sign" ]; then
            echo " L: Signing $outfile"
            run_jar "$l/zipsigner.jar" "$folder/try.apk" "$folder/try.zp" >/dev/null
            if [ ! -e "$folder/try.zp" ]; then echo "ERROR: sign $outfile" && return 1; fi
            mv -f "$folder/try.zp" "$folder/try.apk"
         fi
         if [[ -n "$zipa" || "$ext" == "apk" || -n "$ps" ]]; then
            echo " L: Zipaligning $(basename "$outfile")"
            zipalign -f -v 4 "$folder/try.apk" "$folder/try.zp" >/dev/null
            if [ ! -e "$folder/try.zp" ]; then echo "ERROR: zipalign $outfile" && return 1; fi
            mv -f "$folder/try.zp" "$folder/try.apk"
         fi
         if [[ -n "$move" && ! -d "$(dirname "$move")" ]]; then mkdir -p "$(dirname "$move")"; fi
         if [ -n "$move" ]; then
            cp -pf "$folder/try.apk" "$move"
            if is_valid "$move"; then
               rm -f "$folder/try.apk"
               echo " L: Success $(basename "$move")" && return 0
            else
               echo " L: ERROR $(basename "$move")" && return 1
            fi
         else
            mkdir -p "$folder/dist"
            cp -pf "$folder/try.apk" "$folder/dist/$outfile"
            if is_valid "$folder/dist/$outfile"; then
               rm -f "$folder/try.apk"
               echo " L: Success $outfile" && return 0
            else
               echo " L: ERROR $outfile" && return 1
            fi
         fi
   else
      echo "dynamic_apktool: Invalid line" && return 1
   fi
}

find_apk() {
   local userlist package try restore flag re result
   local array path try2 limit count=0 return=1
   local check_split splits overlays check
   if ! aapt version >/dev/null; then echo " CANT LOAD AAPT: U cant use find_apk " && return 1; fi
   restore=()
   while [[ $# -gt 0 ]]; do
   flag="$1"
   case $flag in
       -r|-recursive)
       re=true
       shift
       ;;
       -l|-limit)
       limit="$2"
       shift;shift;
       ;;
       -is|-include-splits)
       splits=true
       shift
       ;;
       -io|-include-overlays)
       overlays=true
       shift
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
   esac
   done
   set -- "${restore[@]}"
   delete "$TMP/userlist.txt"
   delete "$TMP/packages.txt"
   if defined limit && ! is_number $limit; then echo2 " find_apk: Invalid line" && return 1; fi
   array=( "$@" )
   path=${array[${#array[@]} - 1]}
   unset "array[${#array[@]}-1]"
   while read userlist; do
       if undefined userlist; then echo "find_apk: Cant find any apk in $path " && return 1; fi
       package=
       package=$(apk_package "$userlist")
       if defined package; then
          echo "$userlist" >> "$TMP/userlist.txt"
          echo "$(basename "$userlist")=$package" >> "$TMP/packages.txt"
       fi
   done <<< $(find "$path" -type f -name "*.apk")
   for try in "${array[@]}"; do
     while read try2; do
        undefined try2 && continue
        package=
        package=$(get_file_prop "$TMP/packages.txt" "$try2")
        check=$(grep -m1 "$try2" "$TMP/userlist.txt")
        check_split=$(aapt dump badging "$check" | sed -n "s/.* split='\([^']*\).*$/\1/p")
        check_overlay=$(aapt dump xmlstrings "$check" AndroidManifest.xml | grep -w " overlay")
        if [ -z "$re" ]; then
           if [[ -z "$splits" && -z "$overlays" ]]; then
              if [[ -z "$check_split" && -z "$check_overlay" && "$package" == "$try" ]]; then echo "$(grep -m1 "$try2" "$TMP/userlist.txt")" && return=0 && count=$(( $count + 1 )); fi;
           elif [ -n "$splits" ]; then
              if [[ -z "$check_overlay" && "$package" == "$try" ]]; then echo "$(grep -m1 "$try2" "$TMP/userlist.txt")" && return=0 && count=$(( $count + 1 )); fi;
           elif [ -n "$overlays" ]; then
              if [[ -z "$check_split" && "$package" == "$try" ]]; then echo "$(grep -m1 "$try2" "$TMP/userlist.txt")" && return=0 && count=$(( $count + 1 )); fi;
           else
              if [[ "$package" == "$try" ]]; then echo "$(grep -m1 "$try2" "$TMP/userlist.txt")" && return=0 && count=$(( $count + 1 )); fi;
           fi
        else
           result=
           result=$(grep -m1 "$try2" "$TMP/userlist.txt")
           if [ -n "$result" ]; then echo "$result" && return=0 && count=$(( $count + 1 )); fi
        fi
        if [[ -n "$limit" && "$limit" == "$count" ]]; then break; fi
     done <<< $(grep "$try" "$TMP/packages.txt" | cut -d '=' -f1)
   done
   return $return
}

apk_package() {
   local package
   if ! aapt version >/dev/null; then echo " CANT LOAD AAPT: U cant use apk_package " && return 1; fi
   package=$(aapt dump badging "$1" | sed -n "s/.*package: name='\([^']*\).*$/\1/p" 2>/dev/null)
   if [ -n "$package" ]; then echo "$package"; else return 1; fi
}

apk_pkg() {
   apk_package "$@"
}

patch_apk() {
    local current=${PWD} stock new
    if ! exist "$1" "$2"; then echo2 "patch_apk: Invalid line" && return 1; fi
    cp -pf "$2" "$TMP"
    savestate stock "$TMP/$(basename "$2")"
    cd "$1" && zip -r "$TMP/$(basename "$2")" * >/dev/null
    cd "$current"
    savestate new "$TMP/$(basename "$2")"
    if [[ "$stock" != "$new" ]]; then echo "Patched: $2"; else echo "No changes: $2" && return 1; fi
    if [[ "$3" == "zipalign" ]]; then
       zipalign -f -v 4 "$TMP/$(basename "$2")" "$TMP/$(basename "$2").zp" >/dev/null
       if [ -e "$TMP/$(basename "$2").zp" ]; then
          echo2 "Zipaligned: $2"
          mv -f "$TMP/$(basename "$2").zp" "$TMP/$(basename "$2")"
       else
          echo2 "ERROR: zipalign $2" && return 1
       fi
    fi
    if [[ "$3" == "sign" ]]; then
       if [ ! -e $l/zipsigner.jar ]; then ui_print " Cant find zipsigner.jar " && return 1; fi
       run_jar "$l/zipsigner.jar" "$TMP/$(basename "$2")" "$TMP/$(basename "$2").zp" >/dev/null
       if [ -e "$TMP/$(basename "$2").zp" ]; then
          echo2 "Signed: $2"
          mv -f "$TMP/$(basename "$2").zp" "$TMP/$(basename "$2")"
       else
          echo2 "ERROR: sign $2" && return 1
       fi
    fi
    if is_valid "$TMP/$(basename "$2")"; then inject "$TMP/$(basename "$2")" "$(dirname "$2")"; else echo2 "FATAL ERROR: $TMP/$(basename "$2")" && return 1; fi
}

patch_apk_addon() {
   patch_apk "$addons/$1" "$2" "$3"
}

patch_apk_zip() {
    local result
    rm -rf "$TMP/patch_apk"
    package_extract_dir "$1" "$TMP/patch_apk"
    patch_apk "$TMP/patch_apk" "$2" "$3"
    result=$?
    rm -rf "$TMP/patch_apk"
    return $result
}

progress() {
    # command & progress
    local pid=$! huh delay=0.1 limit=10 count=0 anim='|/-\' finish=10 mark="=========================================="
    while kill -0 "$pid" 2> /dev/null; do
        sleep $delay
        local temp=${anim#?}
        local pd=$(( $count * 73 / $finish ))
        if [[ "$count" == "2" ]]; then sleep 0.3 && count=$(( $count + 1 )); fi
        if [[ "$count" == "3" ]]; then sleep 0.3 && count=$(( $count + 1 )); fi
        if [[ "$count" -le "4" ]]; then count=$(( $count + 1 )); fi
        printf "\r %c %3d.%1d%% %.${pd}s" $anim $(( $count * 100 / $finish )) $(( ($count * 1000 / $finish) % 10 )) $mark
        local anim=$temp${anim%"$temp"}
    done
    while [[ $count -lt $limit ]]; do
        sleep $delay
        local temp=${anim#?}
        local pd=$(( $count * 73 / $finish ))
        count=$(( $count + 1 ))
        printf "\r %c %3d.%1d%% %.${pd}s" $anim $(( $count * 100 / $finish )) $(( ($count * 1000 / $finish) % 10 )) $mark
        local anim=$temp${anim%"$temp"}
    done
    echo
}

progress_print() {
    # command & progress_print " file to print"
    local pid=$! check check2 idk=0 file="$1" delay=0 count=0
    local huh limit uwu
    limit=$(cat "$file" | wc -l)
    huh=$(( $limit / 4 ))
    while read uwu; do
       while kill -0 "$pid" 2> /dev/null; do
           count=$(( $count + 1 ))
           sleep $delay
           if [[ "$uwu" != "$check" ]]; then
              if [[ "$count" -lt "$huh" ]]; then 
                 ui_print "$uwu"
              fi
              if [[ "$count" -lt "$(( $count * 2 ))" ]]; then 
                 ui_print "$uwu"
              fi
           fi
           check="$uwu"
       done
       while [[ "$idk" -lt "$limit" ]]; do
         if [[ "$uwu" != "$check2" && "$uwu" != "$check" ]]; then
            idk=$(( $idk + 1 ))
            sleep $delay
            ui_print "$uwu"
            check2="$uwu"
         else
            break
         fi
       done
    done < "$file"
    echo
}


progress_script() {
   local huh
   #progress_script script/commands
   huh="$@"
   if [ -z "$huh" ]; then return; fi
   $("$@" >/dev/null 2>&1) & progress
}

start_loading() {
   #start_loading -s 10 -f 100 -a '|/-\' -l [..................................]
   #start_loading -s(tart) 10 -f(inish) 100 -d(elay) 0.5 -a(nimation) '|/-\' -l(inear) [..................................]
   local complete=$(getvalue s $@ 2>/dev/null)
   export mark=$(getvalue l $@ 2>/dev/null)
   export loafinish=$(getvalue f $@ 2>/dev/null)
   export delay=$(getvalue d $@ 2>/dev/null)
   export loacount=0
   export anim=$(getvalue a $@ 2>/dev/null)
   for huh in complete loafinish; do
      uwu=$(checkvar $huh)
      if [ -z "$uwu" ]; then
         echo "start loading: Fatal line" && return
      fi
   done
   if [ -z "$delay" ]; then export delay="0.3" ; fi;
   while [[ $loacount -lt $loafinish && $loacount -lt $complete ]]; do
     sleep $delay
     local temp=${anim#?}
     export loacount=$(( $loacount + 1 ))
     export pd=$(( $loacount * 73 / $loafinish ))
     if [[ -n "$mark" && -n "$anim" ]]; then
        printf "\r %c %3d.%1d%% %.${pd}s" $anim $(( $loacount * 100 / $loafinish )) $(( ($loacount * 1000 / $loafinish) % 10 )) $mark
        local anim=$temp${anim%"$temp"}
     elif [[ -z "$mark" && -n "$anim" ]]; then
        printf "\r %c %3d.%1d%%" $anim $(( $loacount * 100 / $loafinish )) $(( ($loacount * 1000 / $loafinish) % 10 ))
        local anim=$temp${anim%"$temp"}
     elif [[ -n "$mark" && -z "$anim" ]]; then
        printf "\r%3d.%1d%% %.${pd}s" $(( $loacount * 100 / $loafinish )) $(( ($loacount * 1000 / $loafinish) % 10 )) $mark
     else
       printf "\r%3d.%1d%%" $(( $loacount * 100 / $loafinish )) $(( ($loacount * 1000 / $loafinish) % 10 ))
     fi
   done
   if [[ "$loacount" -ge "$loafinish" ]]; then echo ; fi;
}

add_loading() {
   local complete=$1
   local add=0
   for huh in complete loafinish; do
      uwu=$(checkvar $huh)
      if [ -z "$uwu" ]; then
         echo "add loading: Fatal line or undefined start_loading" && return
      fi
   done
   while [[ $loacount -lt $loafinish && $add -lt $complete ]]; do
     sleep $delay
     local temp=${anim#?}
     export loacount=$(( $loacount + 1 ))
     add=$(( $add + 1 ))
     export pd=$(( $loacount * 73 / $loafinish ))
     if [[ -n "$mark" && -n "$anim" ]]; then
        printf "\r %c %3d.%1d%% %.${pd}s" $anim $(( $loacount * 100 / $loafinish )) $(( ($loacount * 1000 / $loafinish) % 10 )) $mark
        local anim=$temp${anim%"$temp"}
     elif [[ -z "$mark" && -n "$anim" ]]; then
        printf "\r %c %3d.%1d%%" $anim $(( $loacount * 100 / $loafinish )) $(( ($loacount * 1000 / $loafinish) % 10 ))
        local anim=$temp${anim%"$temp"}
     elif [[ -n "$mark" && -z "$anim" ]]; then
        printf "\r%3d.%1d%% %.${pd}s" $(( $loacount * 100 / $loafinish )) $(( ($loacount * 1000 / $loafinish) % 10 )) $mark
     else
       printf "\r%3d.%1d%%" $(( $loacount * 100 / $loafinish )) $(( ($loacount * 1000 / $loafinish) % 10 ))
     fi
   done
   if [[ "$loacount" -ge "$loafinish" ]]; then echo ; fi;
}

smali_kit() {
   #Smali Tool kit for Dynamic Installer by BlassGO
   local dir num line liner old new count=0 restore load try log result
   local file path method replace limit rim newline oldline check stock edit smaliname remake
   local get al al_add bl bl_add staticname dim dim_oldline justprint printpath prev dm
   local restore flag 
   delete "$TMP/smali_kit"
   restore=()
   while [[ $# -gt 0 ]]; do
   flag="$1"
   case $flag in
       -f|-file)
       file="$2"
       shift;shift;
       ;;
       -d|-dir)
       path="$2"
       shift;shift;
       ;;
       -m|-method)
       method="$2"
       shift;shift;
       ;;
       -r|-replace)
       replace="$2"
       shift;shift;
       ;;
       -rim|-replace-in-method)
       rim=true
       oldline="$2"
       newline="$3"
       shift;shift;shift;
       ;;
       -dim|-delete-in-method)
       dim=true
       dim_oldline="$2"
       shift;shift;
       ;;
       -re|-remake)
       remake="$2"
       shift;shift;
       ;;
       -al|-after-line)
       al="$2"
       al_add="$3"
       shift;shift;shift;
       ;;
       -bl|-before-line)
       bl="$2"
       bl_add="$3"
       shift;shift;shift;
       ;;
       -c|-check)
       check=true
       shift
       ;;
       -n|-name)
       smaliname="$2"
       shift;shift;
       ;;
       -sn|-static-name)
       staticname="$2"
       shift;shift;
       ;;
       -l|-limit)
       limit="$2"
       shift;shift;
       ;;
       -pp|-print-path)
       printpath=true
       shift
       ;;
       -dm|-delete-method)
       dm=true
       shift
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
   esac
   done
   set -- "${restore[@]}"
   if [[ -z "$file" && -n "$path" && -n "$method" ]]; then
      if [ ! -d "$path" ]; then echo2 "CANT FIND: $path" && return 1; fi
      grep -rnw "$path" -e "$method" | while read huh; do
         undefined huh && break
         stock=
         edit=
         dir=$(echo "$huh" | cut -f1 -d:)
         num=$(echo "$huh" | cut -f2 -d:)
         liner=$(echo "$huh" | cut -f3 -d:)
         [ ! -f "$dir" ] && continue
         [ -z "$liner" ] && continue
         if [[ "$liner" == *".method"* && "$liner" != *".method abstract"* && "$liner" != *".method public abstract"* ]]; then
            if [[ -n "$staticname" && "$(basename "$dir")" != "$staticname" ]]; then continue; fi
            if [[ -n "$smaliname" && "$(basename "$dir")" != *"$smaliname"* ]]; then continue; fi
            if [ -n "$printpath" ]; then if [[ "$dir" != "$prev" ]]; then 
               count=$(( $count + 1 ))
               echo "$dir"
               echo 0 > "$TMP/smali_kit"
               if [[ -n "$limit" && "$limit" == "$count" ]]; then break; fi
               prev="$dir" && justprint=true && continue
            fi; fi
            line="$liner"
            savestate stock "$dir"
            if [[ -z "$replace" && -z "$rim" && -z "$remake" && -z "$al" && -z "$bl" && -z "$dim" && -z "$printpath" && -z "$dm" ]]; then
               justprint=true
               echo "path=$dir"
               string -f "$dir" complete_extract "$line" ".end method"
            fi
            if [ -n "$replace" ]; then
               load=$(cat "$dir")
               old=$(string complete_extract "$line" ".end method" "$load")
               result=${load/"$old"/"$replace"}
               echo "$result" > "$dir"
            fi
            if [[ -n "$rim" && -n "$oldline" && -n "$newline" ]]; then
               load=$(cat "$dir")
               old=$(string complete_extract "$line" ".end method" "$load")
               try=${old/"$oldline"/"$newline"}
               result=${load/"$old"/"$try"}
               echo "$result" > "$dir"
            fi
            if [[ -n "$dim" && -n "$dim_oldline" ]]; then
               load=$(cat "$dir")
               old=$(string complete_extract "$line" ".end method" "$load")
               try=${old//"$dim_oldline"/}
               result=${load/"$old"/"$try"}
               echo "$result" > "$dir"
            fi
            if [ -n "$remake" ]; then
               load=$(cat "$dir")
               old=$(string complete_extract "$line" ".end method" "$load")
               echo "$liner" > "$TMP/re.tmp"
               echo "$remake" >> "$TMP/re.tmp"
               echo "${n}.end method" >> "$TMP/re.tmp"
               try=$(cat "$TMP/re.tmp")
               rm -f "$TMP/re.tmp" 2>/dev/null
               result=${load/"$old"/"$try"}
               echo "$result" > "$dir"
            fi
            if [[ -n "$bl" && -n "$bl_add" ]]; then
               load=$(cat "$dir")
               old=$(string complete_extract "$line" ".end method" "$load")
               try=$(string -before-line "$bl" "$bl_add" "$old")
               result=${load/"$old"/"$try"}
               echo "$result" > "$dir"
            fi
            if [[ -n "$al" && -n "$al_add" ]]; then
               load=$(cat "$dir")
               old=$(string complete_extract "$line" ".end method" "$load")
               try=$(string -after-line "$al" "$al_add" "$old")
               result=${load/"$old"/"$try"}
               echo "$result" > "$dir"
            fi
            if [ -n "$dm" ]; then
               load=$(cat "$dir")
               old=$(string complete_extract "$line" ".end method" "$load")
               result=${load//"$old"/}
               echo "$result" > "$dir"
            fi
            savestate edit "$dir"
            if [ -z "$printpath" ]; then count=$(( $count + 1 )); fi
            if [ -n "$check" ]; then if [[ "$edit" != "$stock" ]]; then ui_print "Edited: \"$dir\""; else ui_print "Nothing: \"$dir\""; fi; fi
            if [[ "$edit" != "$stock" ]]; then echo 0 > "$TMP/smali_kit"; else echo 1 > "$TMP/smali_kit"; fi
            if [ -n "$justprint" ]; then echo 0 > "$TMP/smali_kit"; fi
            if [[ -n "$limit" && "$limit" == "$count" ]]; then break; fi
         fi
      done
   elif [[ -n "$file" && -z "$path" && -n "$method" ]]; then
      if [ ! -f "$file" ]; then echo2 "CANT FIND: $file" && return 1; fi
      grep -nw "$file" -e "$method" | while read huh; do
         undefined huh && break
         stock=
         edit=
         dir="$file"
         num=$(echo "$huh" | cut -f1 -d:)
         liner=$(echo "$huh" | cut -f2 -d:)
         [ -z "$liner" ] && continue
         if [[ "$liner" == *".method"* && "$liner" != *".method abstract"* && "$liner" != *".method public abstract"* ]]; then
            if [[ -n "$staticname" && "$(basename "$dir")" != "$staticname" ]]; then continue; fi
            if [[ -n "$smaliname" && "$(basename "$dir")" != *"$smaliname"* ]]; then continue; fi
            if [ -n "$printpath" ]; then if [[ "$dir" != "$prev" ]]; then 
               count=$(( $count + 1 ))
               echo "$dir"
               echo 0 > "$TMP/smali_kit"
               if [[ -n "$limit" && "$limit" == "$count" ]]; then break; fi
               prev="$dir" && justprint=true && continue
            fi; fi
            line="$liner"
            savestate stock "$dir"
            if [[ -z "$replace" && -z "$rim" && -z "$remake" && -z "$al" && -z "$bl" && -z "$dim" && -z "$printpath" && -z "$dm" ]]; then
               justprint=true
               echo "path=$dir"
               string -f "$dir" complete_extract "$line" ".end method"
            fi
            if [ -n "$replace" ]; then
               load=$(cat "$dir")
               old=$(string complete_extract "$line" ".end method" "$load")
               result=${load/"$old"/"$replace"}
               echo "$result" > "$dir"
            fi
            if [[ -n "$rim" && -n "$oldline" && -n "$newline" ]]; then
               load=$(cat "$dir")
               old=$(string complete_extract "$line" ".end method" "$load")
               try=${old/"$oldline"/"$newline"}
               result=${load/"$old"/"$try"}
               echo "$result" > "$dir"
            fi
            if [[ -n "$dim" && -n "$dim_oldline" ]]; then
               load=$(cat "$dir")
               old=$(string complete_extract "$line" ".end method" "$load")
               try=${old//"$dim_oldline"/}
               result=${load/"$old"/"$try"}
               echo "$result" > "$dir"
            fi
            if [ -n "$remake" ]; then
               load=$(cat "$dir")
               old=$(string complete_extract "$line" ".end method" "$load")
               echo "$liner" > "$TMP/re.tmp"
               echo "$remake" >> "$TMP/re.tmp"
               echo "${n}.end method" >> "$TMP/re.tmp"
               try=$(cat "$TMP/re.tmp")
               rm -f "$TMP/re.tmp" 2>/dev/null
               result=${load/"$old"/"$try"}
               echo "$result" > "$dir"
            fi
            if [[ -n "$bl" && -n "$bl_add" ]]; then
               load=$(cat "$dir")
               old=$(string complete_extract "$line" ".end method" "$load")
               try=$(string -before-line "$bl" "$bl_add" "$old")
               result=${load/"$old"/"$try"}
               echo "$result" > "$dir"
            fi
            if [[ -n "$al" && -n "$al_add" ]]; then
               load=$(cat "$dir")
               old=$(string complete_extract "$line" ".end method" "$load")
               try=$(string -after-line "$al" "$al_add" "$old")
               result=${load/"$old"/"$try"}
               echo "$result" > "$dir"
            fi
            if [ -n "$dm" ]; then
               load=$(cat "$dir")
               old=$(string complete_extract "$line" ".end method" "$load")
               result=${load//"$old"/}
               echo "$result" > "$dir"
            fi
            savestate edit "$dir"
            if [ -z "$printpath" ]; then count=$(( $count + 1 )); fi
            if [ -n "$check" ]; then if [[ "$edit" != "$stock" ]]; then ui_print "Edited: \"$dir\""; else ui_print "Nothing: \"$dir\""; fi; fi
            if [[ "$edit" != "$stock" ]]; then echo 0 > "$TMP/smali_kit"; else echo 1 > "$TMP/smali_kit"; fi
            if [ -n "$justprint" ]; then echo 0 > "$TMP/smali_kit"; fi
            if [[ -n "$limit" && "$limit" == "$count" ]]; then break; fi
         fi
      done
   else
      echo " smali_kit: Invalid line " && return 1
   fi
   if [ -f "$TMP/smali_kit" ]; then return $(cat "$TMP/smali_kit"); else return 1; fi
}

apex_pkg() {
    #Based on Magisk method
    local pattern='s/.*"name":[^"]*"\([^"]*\).*/\1/p' apex="$1" dest
    local pattern2='s/.*package="\([^"]*\).*$/\1/p'
    if [ -f "$apex/apex_manifest.json" ]; then
        dest=$(sed -n $pattern "$apex/apex_manifest.json")
    elif [ -f "$apex/apex_manifest.pb" ]; then
        dest=$(strings "$apex/apex_manifest.pb" | head -n 1)
    fi
    [ ! -z "$dest" ] && echo "$dest" && return
    dest=$(unzip -qp "$apex" apex_manifest.pb | strings | head -n 1)
    [ -z "$dest" ] && dest=$(unzip -qp "$apex" apex_manifest.json | sed -n $pattern)
    [ -z "$dest" ] && dest=$(unzip -qp "$apex" apex_build_info.pb | sed -n $pattern2)
    [ ! -z "$dest" ] && echo "$dest" || return 1
}

getarch() {
  local try info prop system_prop vendor_prop
  if ! $BOOTMODE; then
     try_mount -e -n system /systemtmp 2>/dev/null
     try_mount -e -n vendor /vendortmp 2>/dev/null
     if is_mounted /systemtmp; then
        if [ -f /systemtmp/build.prop ]; then
           system_prop=/systemtmp/build.prop
        elif [ -f /systemtmp/system/build.prop ]; then
           system_prop=/systemtmp/system/build.prop
        fi
        free_system=$((df -Pk /systemtmp | sed "1d" | awk '{print $4}') 2>/dev/null)
     fi
     if is_mounted /vendortmp; then
        if [ -f /vendortmp/build.prop ]; then
           vendor_prop=/vendortmp/build.prop
        fi
        free_vendor=$((df -Pk /vendortmp | sed "1d" | awk '{print $4}') 2>/dev/null)
     elif [ -f /systemtmp/vendor/build.prop ]; then
           vendor_prop=/systemtmp/vendor/build.prop
           free_vendor=$free_system
     elif [ -f /systemtmp/system/vendor/build.prop ]; then
           vendor_prop=/systemtmp/system/vendor/build.prop
           free_vendor=$free_system
     fi
  else
     system_prop=/system/build.prop
     vendor_prop=/vendor/build.prop
     [ -f /system/vendor/build.prop ] && vendor_prop=/system/vendor/build.prop
     free_system=$((df -Pk /system | sed "1d" | awk '{print $4}') 2>/dev/null)
     free_vendor=$((df -Pk /vendor | sed "1d" | awk '{print $4}') 2>/dev/null)
  fi
  #Get free space in root /
  free_root=$((df -Pk / | sed "1d" | awk '{print $4}') 2>/dev/null)
  #Convert KB to B
  [ -n "$free_root" ] && free_root=$(calc ${free_root} '*' 1024)
  [ -n "$free_system" ] && free_system=$(calc ${free_system} '*' 1024)
  [ -n "$free_vendor" ] && free_vendor=$(calc ${free_vendor} '*' 1024)
  if [ ! -f "$system_prop" ]; then
     API=`getprop ro.build.version.sdk`
     ABI=`getprop ro.product.cpu.abi | cut -c-3`
     ABI2=`getprop ro.product.cpu.abi2 | cut -c-3`
     ABILONG=`getprop ro.product.cpu.abi`
     PROC=`getprop ro.product.board`
  else
     API=`get_file_prop "$system_prop" ro.build.version.sdk`
     ABI=`get_file_prop "$system_prop" ro.product.cpu.abi | cut -c-3`
     ABI2=`get_file_prop "$system_prop" ro.product.cpu.abi2 | cut -c-3`
     ABILONG=`get_file_prop "$system_prop" ro.product.cpu.abi`
     PROC=`get_file_prop "$system_prop" ro.hardware.chipname`
  fi
  if [ ! -f "$vendor_prop" ]; then
     virtual_partitions=`getprop ro.virtual_ab.enabled`
     dynamic_partitions=`getprop ro.boot.dynamic_partitions`
  else
     virtual_partitions=`get_file_prop "$vendor_prop" ro.virtual_ab.enabled`
     dynamic_partitions=`get_file_prop "$vendor_prop" ro.boot.dynamic_partitions`
  fi
  [ -z "$dynamic_partitions" ] && dynamic_partitions=false
  [ -z "$virtual_partitions" ] && virtual_partitions=false
  for slot in "$(grep_cmdline androidboot.slot_suffix)" "$(grep_cmdline androidboot.slot)" "$(getprop ro.boot.slot_suffix)"; do
     if [ -n "$slot" ]; then
        if is_substring _ "$slot"; then export slot=$slot && break; else export slot=_${slot} && break; fi
     fi
  done
  if [ -z "$PROC" ]; then
     PROC=$(grep_cmdline androidboot.hardware)
  fi
  #Some Exynos devices use ro.hardware
  if is_substring exynos "$(getprop ro.hardware)"; then PROC=$(getprop ro.hardware); fi
  encrypted=true
  touch /data/.rw && rm /data/.rw && encrypted=false
  status=$(getenforce)
  arch=arm
  arch32=arm
  is64bit=false
  if [ -e "/proc/cpuinfo" ]; then 
     try=$(cat /proc/cpuinfo | grep -m1 "architecture" | cut -d':' -f2 | tr -d " ")
     if is_number "$try"; then
        if [[ "$try" == "8" ]]; then native_arch=arm64
        elif [[ "$try" == "7" ]]; then native_arch=arm
        fi
     else
        echo2 " Warning: ABnormal architecture"
     fi
     if $(cat /proc/cpuinfo | grep -m1 "Hardware" | grep -q "Qualcomm"); then chipname=snapdragon
     elif $(cat /proc/cpuinfo | grep -m1 "Hardware" | grep -q "Kirin"); then chipname=kirin
     elif $(cat /proc/cpuinfo | grep -m1 "Hardware" | grep -q "Unisoc"); then chipname=unisoc
     elif $(cat /proc/cpuinfo | grep -m1 "Hardware" | grep -q "MT"); then chipname=mediatek
     elif defined PROC && is_substring "exynos" "$PROC"; then chipname=exynos
     fi
  fi
  if [ "$ABI" = "x86" ]; then arch=x86; arch32=x86; fi;
  if [ "$ABI2" = "x86" ]; then arch=x86; arch32=x86; fi;
  if [ "$ABILONG" = "arm64-v8a" ]; then arch=arm64; arch32=arm; is64bit=true; base_lib=64; fi;
  if [ "$ABILONG" = "x86_64" ]; then arch=x64; arch32=x86; is64bit=true; base_lib=64; fi;
  echo2 "------------Device INFO------------"
  for info in API ABI ABI2 ABILONG PROC arch arch32 native_arch is64bit chipname status encrypted slot dynamic_partitions virtual_partitions free_root free_system free_vendor; do
     if defined $info; then echo2 "$info=$(checkvar $info)"; fi
  done
  echo2 "-----------------------------------"
  if ! $BOOTMODE; then
     unmount /systemtmp
     unmount /vendortmp
     is_mounted /systemtmp || delete_recursive /systemtmp
     is_mounted /vendortmp || delete_recursive /vendortmp
  fi
}

getsecurity() {
  local avb avb2 info
  if ! can_run avbctl; then echo2 "FATAL ERROR: Please import/use valid avbctl" && return 1; fi
  if $is64bit; then
     avb=$(avbctl get-verity)
     avb2=$(avbctl get-verification)
     if is_substring "verity is enabled" "$avb"; then VERITY=enabled
     elif is_substring "verity is disabled" "$avb"; then VERITY=disabled
     fi
     if is_substring "verification is enabled" "$avb2"; then VERIFICATION=enabled
     elif is_substring "verification is disabled" "$avb2"; then VERIFICATION=disabled
     fi
  fi
  for info in VERITY VERIFICATION; do
     if defined $info; then echo2 "> $info=$(checkvar $info)"; fi
  done
  echo2 " "
}

disable_avb() {
   #It may cause problems in samsung devices (Risk)
   if ! can_run avbctl; then echo2 "FATAL ERROR: Please import/use valid avbctl" && return 1; fi
   getsecurity 2>/dev/null
   if $is64bit; then
      if [[ "$VERIFICATION" == "enabled" ]]; then avbctl --force disable-verification > /dev/null; fi
      if [[ "$VERITY" == "enabled" ]]; then avbctl --force disable-verity > /dev/null; fi
   fi
   getsecurity
}

enable_avb() {
   if ! can_run avbctl; then echo2 "FATAL ERROR: Please import/use valid avbctl" && return 1; fi
   getsecurity 2>/dev/null
   if $is64bit; then
      if [[ "$VERIFICATION" == "disabled" ]]; then avbctl --force enable-verification > /dev/null; fi
      if [[ "$VERITY" == "disabled" ]]; then avbctl --force enable-verity > /dev/null; fi
   fi
   getsecurity
}

getbins() {
  local support pos
  unset bins
  while read support; do
     while read pos; do
      if [ -d "$support" ] && ! is_substring "$pos" "$bins"; then export bins+="$pos:" && echo "$pos"; fi
     done <<< $(basename "$(ls "$support" 2>/dev/null)")
  done <<< $(split_string : "$PATH")
}

run() {
    local file var
    file=$(fullpath "$2")
    var="$1"
    [ ! -f "$file" ] && return 1
    [ -z "$var" ] && return 1
    shift 2
    chmod 777 "$file"
    setdefault "$var" "$("$file" "$@" 2>&1)"
}

run_addon() {
    local file var
    file="$2"
    var="$1"
    shift 2
    run "$var" "$addons/$file" "$@"
}

run_zip() {
    local file var
    file="$2"
    var="$1"
    shift 2
    package_extract_file "$file" "$TMP/$(basename "$file")"
    run "$var" "$TMP/$(basename "$file")" "$@"
    rm -f "$TMP/$(basename "$file")"
}

package_extract_file() {
   [ -n "$3" ] && local installzip="$3"
   [ ! -f "$installzip" ] && return 1
   if [[ -n "$1" && -n "$2" ]]; then
      if [ ! -d "$(dirname "$2")" ]; then mkdir -p "$(dirname "$2")"; set_perm2 0 0 $di_perm_d "$(dirname "$2")"; fi
      unzip -qp "$installzip" "$1" > "$2"
      if exist "$2"; then set_perm2 0 0 $di_perm_f "$2"
      else return 1
      fi
   elif [ -n "$1" ]; then
      unzip -qp "$installzip" "$1" || return 1
   else
      return 1
   fi
}

package_extract_dir() {
  local outfile return=0 a
  [ -n "$3" ] && local installzip="$3"
  [ ! -f "$installzip" ] && return 1
  while read a; do
    if undefined a; then return=1 && break; fi
    if [[ -n "$1" && -n "$2" ]]; then
       outfile=$(echo "$a" | sed "s|${1}|${2}|");
       if echo "$a" | grep -q '/$'; then 
          if [ ! -d "$outfile" ]; then mkdir -p "$outfile"; set_perm2 0 0 $di_perm_d "$outfile"; fi
          continue
       elif [ ! -d "$(dirname "$outfile")" ]; then mkdir -p "$(dirname "$outfile")"; set_perm2 0 0 $di_perm_d "$(dirname "$outfile")"
       fi
       unzip -qp "$installzip" "$a" > "$outfile"
       if exist "$outfile"; then set_perm2 0 0 $di_perm_f "$outfile"
       else return=1 && continue
       fi
    elif [ -n "$1" ]; then
       if echo "$a" | grep -q '/$'; then continue; fi
       unzip -qp "$installzip" "$a" || return=1
    else return=1 && break
    fi
  done <<< $(unzip -l "$installzip" | tail -n+4 | grep -o " $1.*$" | cut -c2-)
  return $return
}

getblocks() {
   local block mapper bd result base
   unset all_partitions
   for block in /dev/block/platform/*/by-name/*; do
       if [ -e "$block" ]; then
          result=
          base=
          base=$(basename "$block")
          result=$(readlink -f "$block")
          if defined result && exist "$result"; then
             base=$(string lower "$base")
             setdefault "$base" "$result"
             echo2 "$base=$result"
             export all_partitions+="$result:"
          fi
       fi
   done
   for block in /dev/block/by-name/*; do
       if [ -e "$block" ]; then
          result=
          base=
          base=$(basename "$block")
          result=$(readlink -f "$block")
          if defined result && exist "$result" && ! is_substring "$result" "$all_partitions"; then
             base=$(string lower "$base")
             setdefault "$base" "$result"
             echo2 "$base=$result"
             export all_partitions+="$result:"
          fi
       fi
   done 
   if [[ "$dynamic_partitions" == "true" ]]; then
       while read mapper; do
           if [ -e "$mapper" ]; then
              result=
              base=
              base=$(basename "$mapper")
              result=$(readlink -f "$mapper")
              if defined result && exist "$result" && ! is_substring "$result" "$all_partitions"; then
                 base=$(string lower "$base")
                 setdefault "$base" "$result"
                 echo2 "$base=$result"
                 export all_partitions+="$result:"
              fi
           fi
       done <<< $(find /dev/block/mapper -mindepth 1 -maxdepth 1 \( -type b -o -type c -o -type l \)) 
   fi
   if [ -d /dev/block/bootdevice ]; then
      while read bd; do
           if [ -e "$bd" ]; then
              result=
              base=
              base=$(basename "$bd")
              result=$(readlink -f "$bd")
              if defined result && exist "$result" && ! is_substring "$result" "$all_partitions"; then
                 base=$(string lower "$base")
                 setdefault "$base" "$result"
                 echo2 "$base=$result"
                 export all_partitions+="$result:"
              fi
           fi
       done <<< $(find /dev/block/bootdevice -mindepth 1 -maxdepth 1 \( -type b -o -type c -o -type l \)) 
   fi
}

fprint() {
  local line
  while IFS='' read -r line || [[ -n "$line" ]]; do
    ui_print "$line";
  done < "$1";
}

fprint_zip() {
  package_extract_file "$1" "$TMP/$1"
  fprint "$TMP/$1"
  rm -f "$TMP/$1"
}

fprint_addon() {
  fprint "$addons/$1"
}

update() {
    local bs restore flag xz gz ro
    restore=()
    while [[ $# -gt 0 ]]; do
      flag="$1"
      case $flag in
          -xz)
          xz=true
          shift
          ;;
          -gz)
          gz=true
          shift
          ;;
          *)   
          restore+=("$1")
          shift
          ;;
      esac
    done
    set -- "${restore[@]}"
    if is_number $(string force remove M "$extraction_speed"); then bs=$extraction_speed; else bs=1048576; fi
    if exist "$2"; then
       blockdev --setrw "$2" 2>/dev/null
       ro=$(blockdev --getro "$2" 2>/dev/null)
       if [[ "$ro" == "1" ]]; then
          echo2 "FATAL ERROR: Read/Only: $2"
          if [[ "$3" == "1" ]]; then abort; else return 1; fi
       elif [[ "$ro" != "0" ]]; then
          echo2 "Cant get state: $2"
          echo2 "Skipping: Writing in: $2"
       fi
    fi
    if defined xz; then
       if xz -dc "$1" > "$2"; then
          echo2 " "
		  echo2 "-- Updated:xz: $(basename $1)"
		  echo2 " "
          return 0
       else
          echo2 " "
          echo2 "-- Cant update: $(basename $1)"
          echo2 " "
          if [[ "$3" == "1" ]]; then abort; else return 1; fi
       fi
    elif defined gz; then
       if gunzip -c "$1" > "$2"; then
          echo2 " "
		  echo2 "-- Updated:gz: $(basename $1)"
		  echo2 " "
          return 0
       else
          echo2 " "
          echo2 "-- Cant update: $(basename $1)"
          echo2 " "
          if [[ "$3" == "1" ]]; then abort; else return 1; fi
       fi
    fi
	if simg2img "$1" "$2"; then
        echo2 " "
		echo2 "-- Updated:simg: $(basename $1)"
		echo2 " "
	elif dd if="$1" of="$2" bs=$bs; then
        echo2 " "
		echo2 "-- Updated:1: $(basename $1)"
		echo2 " "
    elif cat "$1" > "$2"; then
        echo2 " "
		echo2 "-- Updated:2: $(basename $1)"
		echo2 " "
    else
        echo2 " "
        echo2 "-- Cant update: $(basename $1)"
        echo2 " "
        if [[ "$3" == "1" ]]; then abort; else return 1; fi
	fi
}

update_addon() {
    local restore flag xz gz
    restore=()
    while [[ $# -gt 0 ]]; do
      flag="$1"
      case $flag in
          -xz)
          xz="-xz"
          shift
          ;;
          -gz)
          gz="-gz"
          shift
          ;;
          *)   
          restore+=("$1")
          shift
          ;;
      esac
    done
    set -- "${restore[@]}"
    update $xz $gz "$addons/$1" "$2" "$3"
}

update_zip() {
    local bs restore flag xz gz
    restore=()
    while [[ $# -gt 0 ]]; do
      flag="$1"
      case $flag in
          -xz)
          xz=true
          shift
          ;;
          -gz)
          gz=true
          shift
          ;;
          *)   
          restore+=("$1")
          shift
          ;;
      esac
    done
    set -- "${restore[@]}"
    if is_number $(string force remove M "$extraction_speed"); then bs=$extraction_speed; else bs=1048576; fi
    if exist "$2"; then
       blockdev --setrw "$2" 2>/dev/null
       ro=$(blockdev --getro "$2" 2>/dev/null)
       if [[ "$ro" == "1" ]]; then
          echo2 "FATAL ERROR: Read/Only: $2"
          if [[ "$3" == "1" ]]; then abort; else return 1; fi
       elif [[ "$ro" != "0" ]]; then
          echo2 "Cant get state: $2"
          echo2 "Skipping: Writing in: $2"
       fi
    fi
    if defined xz; then
       if unzip -qp "$installzip" "$1" | xz -dc > "$2"; then
          echo2 " "
		  echo2 "-- Updated:xz: $(basename $1)"
		  echo2 " "
          return 0
       else
          echo2 " "
          echo2 "-- Cant update: $(basename $1)"
          echo2 " "
          if [[ "$3" == "1" ]]; then abort; else return 1; fi
       fi
    elif defined gz; then
       if unzip -qp "$installzip" "$1" | gunzip -c - > "$2"; then
          echo2 " "
		  echo2 "-- Updated:gz: $(basename $1)"
		  echo2 " "
          return 0
       else
          echo2 " "
          echo2 "-- Cant update: $(basename $1)"
          echo2 " "
          if [[ "$3" == "1" ]]; then abort; else return 1; fi
       fi
    fi
	if unzip -qp "$installzip" "$1" | dd of="$2" bs=$bs; then
        echo2 " "
		echo2 "-- Updated:1: $(basename $1)"
		echo2 " "
    elif unzip -qp "$installzip" "$1" > "$2"; then
        echo2 " "
		echo2 "-- Updated:2: $(basename $1)"
		echo2 " "
    else
        echo2 " "
        echo2 "-- Cant update: $(basename $1)"
        echo2 " "
        if [[ "$3" == "1" ]]; then abort; else return 1; fi
	fi
}

get_file_prop() {
  local file prop try i=0
  # a b c -> c a b
  while [ $((i+=1)) -lt $# ]; do
    set -- "$@" "$1"
    shift
  done
  prop="$1"
  shift
  [ -z "$prop" ] && return 1
  for file in "$@"; do
     try=$(cat "$file" 2>/dev/null | dos2unix | grep -Fm1 "${prop}=" | cut -d= -f2)
     [ -n "$try" ] && echo "$try" && return 0
  done
  return 1
}

set_progress() { if ! $BOOTMODE; then echo "set_progress $1" >> $OUTFD; fi }

ui_print() {
  until [ ! "$1" ]; do
     if ! $BOOTMODE; then
        if [ $(echo "$1" | wc -l) -gt 2 ]; then
           local IFS=$'\n' line
           for line in $1; do
             [ -n "$OUTFD" ] && echo "ui_print $line${n}ui_print" >> $OUTFD
             [ -z "$OUTFD" ] && echo "$line"
           done
        else
           [ -n "$OUTFD" ] && echo "ui_print $1${n}ui_print" >> $OUTFD
           [ -z "$OUTFD" ] && echo "$1"
        fi
     else 
       echo "$1"
     fi
     shift
  done
}

ch_con() {
  local con return=0
  if [ -n "$1" ]; then is_substring u:object "$1" && con=$1 || con=u:object_r:$1:s0; else return 1; fi
  shift
  while [ "$1" ]; do
    [[ "$con" == "$(get_context "$1")" ]] && shift && continue
    echo2 "set_context: $con in $1"
    chcon -h $con "$1" 2>/dev/null || chcon $con "$1"
    shift
  done
  return $return
}

ch_con_recursive() {
    local dcon fcon file folder s=0
    local restore flag f d
    restore=()
    while [[ $# -gt 0 ]]; do
    flag="$1"
    case $flag in
       -f|-file)
       f=true
       shift
       ;;
       -d|-dir)
       d=true
       shift
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
    esac
    done
    set -- "${restore[@]}"
    if defined d; then is_substring u:object "$1" && dcon=$1 || dcon=u:object_r:$1:s0; s=1; fi
    if defined f; then is_substring u:object "$1" && fcon=$1 || fcon=u:object_r:$1:s0; [ "$s" == 0 ] && s=1; fi
    if undefined f d; then
       is_substring u:object "$1" && dcon=$1 || dcon=u:object_r:$1:s0; s=$(( $s + 1 ))
       is_substring u:object "$2" && fcon=$2 || fcon=u:object_r:$2:s0; s=$(( $s + 1 ))
    fi
    [[ $s == 0 ]] && return 1
    shift $s
    while [ "$1" ]; do
      if [ ! -d "$1" ]; then echo2 "CANT FIND: $1" && shift && continue; fi
      [ -n "$dcon" ] && ( find "$1" -type d | while read folder; do ch_con $dcon "$folder"; done)
      [ -n "$fcon" ] && ( find "$1" -type f -o -type l | while read file; do ch_con $fcon "$file"; done)
      shift;
    done;
}

set_perm() {
  local uid gid mod
  [ -n "$1" ] && uid=$1  || return 1
  [ -n "$2" ] && gid=$2 || return 1
  [ -n "$3" ] && mod=$3 || return 1
  shift 3
  chown "$uid:$gid" "$@" 2>/dev/null || chown "$uid.$gid" "$@"
  chmod "$mod" "$@"
}

set_perm2() {
  #Ensure this format
  local uid gid fmod
  [ -n "$1" ] && uid=$1  || return 1
  [ -n "$2" ] && gid=$2 || return 1
  [ -n "$3" ] && fmod=$3 || return 1
  shift 3
  chown "$uid:$gid" "$@" 2>/dev/null || chown "$uid.$gid" "$@"
  chmod "$fmod" "$@"
}

set_perm_recursive() {
  local uid gid dmod fmod
  [ -n "$1" ] && uid=$1  || return 1
  [ -n "$2" ] && gid=$2 || return 1
  [ -n "$3" ] && dmod=$3 || return 1
  [ -n "$4" ] && fmod=$4 || return 1
  shift 4
  while [ "$1" ]; do
    if [ ! -d "$1" ]; then echo2 "CANT FIND: $1" && shift && continue; fi
    chown -R $uid:$gid "$1" 2>/dev/null || chown -R $uid.$gid "$1"
    chmod -R $fmod "$1"
    find "$1" -type l -exec chmod $fmod {} +;
    find "$1" -type d -exec chmod $dmod {} +;
    shift
  done
}

set_perm_recursive2() {
  #Ensure this format
  local uid gid dmod fmod
  [ -n "$1" ] && uid=$1  || return 1
  [ -n "$2" ] && gid=$2 || return 1
  [ -n "$3" ] && dmod=$3 || return 1
  [ -n "$4" ] && fmod=$4 || return 1
  shift 4
  while [ "$1" ]; do
    if [ ! -d "$1" ]; then echo2 "CANT FIND: $1" && shift && continue; fi
    chown -R $uid:$gid "$1" 2>/dev/null || chown -R $uid.$gid "$1"
    chmod -R $fmod "$1"
    find "$1" -type l -exec chmod $fmod {} +;
    find "$1" -type d -exec chmod $dmod {} +;
    shift
  done
}

saveperm() {
   local huh perm list="$TMP/perm_list_001.txt"
   [ ! -f "$list" ] && echo > "$list"
   while [ "$1" ]; do
      if [ -d "$1" ]; then
         echo2 "saving permissions recursively: $1"
         find "$1" -mindepth 1 | while read huh; do
            if ! grep -Fq "$huh=" "$list"; then
               perm=$(get_all_perm "$huh")
               if [ -n "$perm" ]; then
                  echo "$huh=$perm" >> "$list"
               else echo2 "saveperm: CANT get perm of $huh"
               fi
            fi
         done
      elif [ -f "$1" ]; then
         echo2 "saving permissions: $1"
         if ! grep -Fq "$1=" "$list"; then
            perm=$(get_all_perm "$1")
            if [ -n "$perm" ]; then
               echo "$1=$perm" >> "$list"
            else echo2 "saveperm: CANT get perm of $1"
            fi
         fi
      fi
      shift
   done
}

restoreperm() {
   local huh perm list="$TMP/perm_list_001.txt" i=0 flag
   while [ $((i+=1)) -lt $# ]; do
     flag="$1"
     case $flag in
       -file|-f)
       list="$2"
       shift;shift;
       ;;
       *)
       set -- "$@" "$1"
       shift
       ;;
     esac
   done
   while [ "$1" ]; do
      if [ -d "$1" ]; then
         find "$1" -mindepth 1 | while read huh; do
            perm=$(get_file_prop "$list" "$huh" 2>/dev/null)
            if [ -n "$perm" ]; then
               [[ "$perm" == "$(get_all_perm "$huh")" ]] && continue
               echo2 "set_perm: $perm in $huh"
               set_perm2 $perm "$huh"
            else echo2 "set_perm: There is no saved permission for $huh"
            fi
         done
      elif [ -f "$1" ]; then
         perm=$(get_file_prop "$list" "$1" 2>/dev/null)
         if [ -n "$perm" ]; then
            [[ "$perm" == "$(get_all_perm "$1")" ]] && shift && continue
            echo2 "set_perm: $perm in $1"
            set_perm2 $perm "$1"
         else echo2 "set_perm: There is no saved permission for $1"
         fi
      fi
      shift
   done
}

copy_perm_list() {
   list="$TMP/perm_list_001.txt"
   [ -z "$1" ] && return 1
   [ -f "$list" ] && copy "$list" "$1" || return 1
}

savecontext() {
   local huh context list="$TMP/context_list_001.txt"
   [ ! -f "$list" ] && echo > "$list"
   while [ "$1" ]; do
      if [ -d "$1" ]; then
         echo2 "saving contexts recursively: $1"
         find "$1" -mindepth 1 | while read huh; do
            if ! grep -Fq "$huh=" "$list"; then
               context=$(get_context "$huh")
               if [ -n "$context" ]; then
                  echo "$huh=$context" >> "$list"
               else echo2 "savecontext: CANT get context of $huh"
               fi
            fi
         done
      elif [ -f "$1" ]; then
         echo2 "saving context: $1"
         if ! grep -Fq "$1=" "$list"; then
            context=$(get_context "$1")
            if [ -n "$context" ]; then
               echo "$1=$context" >> "$list"
            else echo2 "savecontext: CANT get context of $1"
            fi
         fi
      fi
      shift
   done
}

restorecontext() {
   local huh context list="$TMP/context_list_001.txt" i=0 flag
   while [ $((i+=1)) -lt $# ]; do
     flag="$1"
     case $flag in
       -file|-f)
       list="$2"
       shift;shift;
       ;;
       *)
       set -- "$@" "$1"
       shift
       ;;
     esac
   done
   while [ "$1" ]; do
      if [ -d "$1" ]; then
         find "$1" -mindepth 1 | while read huh; do
            context=$(get_file_prop "$list" "$huh" 2>/dev/null)
            if [ -n "$context" ]; then
               ch_con $context "$huh"
            else echo2 "set_context: There is no saved context for $huh"
            fi
         done
      elif [ -f "$1" ]; then
         context=$(get_file_prop "$list" "$1" 2>/dev/null)
         if [ -n "$context" ]; then
            ch_con $context "$1"
         else echo2 "set_context: There is no saved context for $1"
         fi
      fi
      shift
   done
}

copy_context_list() {
   list="$TMP/context_list_001.txt"
   [ -z "$1" ] && return 1
   [ -f "$list" ] && copy "$list" "$1" || return 1
}

setup_mountpoint() {
  test -L $1 && mv -f $1 ${1}_link
  if [ ! -d $1 ]; then
    rm -f $1
    mkdir $1
  fi
}

is_same_mount() {
   local try try2
   try=$(df -Pk "$1" | sed "1d" | awk '{print $1}' 2>/dev/null)
   try2=$(df -Pk "$2" | sed "1d" | awk '{print $1}' 2>/dev/null)
   defined try try2 || return 1
   if [[ "$try" == "$try2" ]]; then echo2 "[$1:$try] == [$2:$try2]" && return 0; else echo2 "[$1:$try] != [$2:$try2]" && return 1; fi
}

remove_tmp() {
   find "$TMP" -mindepth 1 ! -name "*.log" -delete > /dev/null
}

loop_setup() {
  loopdev=
  local loop
  local minorx=1
  [ -e /dev/block/loop1 ] && minorx=$(stat -Lc '%T' /dev/block/loop1)
  local num=0
  while [ $num -lt 64 ]; do
    loop=/dev/block/loop$num
    [ -e $loop ] || mknod $loop b 7 $((num * minorx))
    if losetup $loop "$1" 2>/dev/null; then
      loopdev=$loop
      break
    fi
    num=$((num + 1))
  done
}

mount_apex() {
  $BOOTMODE || [ ! -d /system/apex ] && return
  local apex dest linkerconfig pkg
  local list="$di_apex_list"
  delete "$list"
  setup_mountpoint /apex
  mount -t tmpfs tmpfs /apex -o mode=755
  for apex in /system/apex/* /system_ext/apex/*; do
    [ ! -e "$apex" ] && continue
    if ! grep -q "^$pkg=" "$list" 2>/dev/null; then apex_mount "$apex"; fi
  done
  export ANDROID_RUNTIME_ROOT=$(find /apex -type d -name "com.android.runtime*")
  export ANDROID_ART_ROOT=$(find /apex -type d -name "com.android.art*")
  export ANDROID_TZDATA_ROOT=$(find /apex -type d -name "com.android.tzdata*")
  export ANDROID_I18N_ROOT=$(find /apex -type d -name "com.android.i18n*")
  export ANDROID_DATA="$TMP/dalvik-cache"
  local APEXJARS=$(find /apex -name '*.jar' | sort | tr '\n' ':')
  local FWK=/system/framework
  delete_recursive "$ANDROID_DATA"
  mkdir -p "$ANDROID_DATA"
  export BOOTCLASSPATH=${APEXJARS}\
$FWK/framework.jar:$FWK/ext.jar:$FWK/telephony-common.jar:\
$FWK/voip-common.jar:$FWK/ims-common.jar:$FWK/telephony-ext.jar
  #Try mount/generate linkerconfig
  if can_run linkerconfig; then linkerconfig=linkerconfig
  elif can_run $ANDROID_RUNTIME_ROOT/bin/linkerconfig; then linkerconfig=$ANDROID_RUNTIME_ROOT/bin/linkerconfig
  elif can_run /system/bin/bootstrap/linkerconfig; then linkerconfig=/system/bin/bootstrap/linkerconfig
  else echo2 "DI: No linkerconfig"
  fi
  if defined linkerconfig; then
     genre_apex_list || echo2 "CANT GENERATE: apex-info-list.xml"
     echo2 " Generating: /linkerconfig"
     setup_mountpoint /linkerconfig
     $linkerconfig --target /linkerconfig
     linkerconfig=$(find /linkerconfig -name '*.txt' | sort | tr '\n' ':')
     all_umount+=("/linkerconfig")
  fi
  export APEX_MOUNT_PASS=true
  echo2 "------------APEX INFO------------"
  for dest in ANDROID_RUNTIME_ROOT ANDROID_ART_ROOT \
  ANDROID_TZDATA_ROOT ANDROID_I18N_ROOT ANDROID_DATA \
  BOOTCLASSPATH DEX2OATBOOTCLASSPATH linkerconfig
  do
     if defined $dest; then echo2 "$dest=$(checkvar $dest)"; fi
  done
  echo2 "-----------------------------------"
}

apex_mount() {
    local apex="$1" dest loopdev
    local list="$di_apex_list"
    if [ -f "$apex" ]; then
         dest=
         dest=$(apex_pkg "$apex")
         [ ! -z "$dest" ] && dest=/apex/$dest || return 1
         [ -d "$dest" ] || mkdir -p "$dest"
         ( if unzip -l "$apex" original_apex | grep -q original_apex; then
            unzip -p "$apex" original_apex | unzip -qo - apex_payload.img -d /apex
         else unzip -qo "$apex" apex_payload.img -d /apex
         fi ) 2>/dev/null
         if [ ! -f /apex/apex_payload.img ]; then is_mounted "$dest" || delete_recursive "$dest"; return 1; fi
         loop_setup /apex/apex_payload.img
         if [ ! -z $loopdev ]; then
           echo "$(basename $dest)=$apex" >> "$list"
           echo2 " Mounting:file: $dest"
           mount -t ext4 -o ro,noatime $loopdev $dest
         fi
         rm -f /apex/apex_payload.img
    elif [ -d "$apex" ]; then
         dest=
         dest=$(apex_pkg "$apex")
         [ ! -z "$dest" ] && dest=/apex/$dest || return 1
         [ -d "$dest" ] || mkdir -p "$dest"
         echo "$(basename $dest)=$apex" >> "$list"
         echo2 " Mounting:folder: $dest" && mount -o bind "$apex" $dest
    fi
}

umount_apex() {
  test -d /apex || return
  local dest loop
  local list="$di_apex_list"
  for dest in $(cat "$list" | cut -d'=' -f1); do
    dest=/apex/$dest
    if [ -d $dest ]; then
       loop=$(mount |  grep $dest |  cut -d" " -f1)
       echo2 " Unmounting $dest "
       umount -ld $dest
       losetup -d $loop 2>/dev/null
    fi
  done
  umount -l /apex
  for dest in ANDROID_RUNTIME_ROOT ANDROID_ART_ROOT \
  ANDROID_TZDATA_ROOT ANDROID_I18N_ROOT ANDROID_DATA \
  BOOTCLASSPATH DEX2OATBOOTCLASSPATH
  do
     unset $dest
  done
}

genre_apex_list() {
   local module_path name apex list count=0
   local list2="$di_apex_list"
   [ -z "$1" ] && list=/apex/apex-info-list.xml || list="$1"
   echo '<?xml version="1.0" encoding="utf-8"?>' > "$list"
   echo '<apex-info-list>' >> "$list"
   for apex in $(cat "$list2" | cut -d'=' -f1); do
     apex=/apex/$apex
     if [ -d $apex ]; then
         name=$(basename $apex)
         module_path=$(get_file_prop "$list2" $name)
         if [ -e "$module_path" ]; then
            count=$(( $count + 1))
            echo " <apex-info moduleName=\"$name\" modulePath=\"$module_path\" preinstalledModulePath=\"$module_path\" isFactory=\"true\" isActive=\"true\" />" >> "$list"
         fi
     fi
   done
   echo '</apex-info-list>' >> "$list"
   if [[ -f "$list" && $count != 0 ]]; then return 0; else delete "$list" && return 1; fi
}

unlock_all() {
   #superrepack by @munjeni
   #unlock_all for Dynamic Installer by @BlassGO
   [ "$(superrepack teSt >/dev/null; echo $?)" == "100" ] && return 1
   local super try count=0 return=0 space current result
   local log=/data/unlock_all.log
   local log2=/data/local/tmp/script.log
   space="/data/superrepack" 
   current=${PWD}
   super=$(find_block -e super)
   [ -z "$super" ] && echo2 "unlock_all: CANT find super partition " && return 1
   delete_recursive "$space"
   delete "$log"
   mkdir -p "$space"
   if ! exist folder "$space"; then echo2 "super_rw: CANT make $space" && return 1; fi
   cd "$space"
   if is_number "$1"; then try="$1"; else try=5; fi
   startlog "$log"
   echolog '>>> Unlock_ALL On-Fly 1.0.0'
   echo2 " "
   echolog " -- Converting $super to RW..."
   echolog " "
   while true; do
      result=
      sleep 1
      [[ "$count" == "$try" ]] && echolog "FATAL ERROR: CANT ENSURE $super as RW with $count attemps" && return=1 && break
      echolog "unlock_all:Attempt: $count"
      count=$(($count + 1))
      superrepack "$super" >> "$log" 2>&1
      result=$?
      savelog "----------------script.log----------------"
      if exist "$log2"; then cat "$log2" >> "$log"; fi
      if [[ "$result" == "0" ]]; then
         if grep -q "Could not allocate block" "$log2"; then continue; else break; fi
      fi
   done
   cd "$current"
   delete_recursive "$space"
   return $return
}

unlock() {
   #superrepack by @munjeni
   #unlock for Dynamic Installer by @BlassGO
   [ "$(superrepack teSt >/dev/null; echo $?)" == "100" ] && return 1
   local super try count=0 return=0 space current result
   local log=/data/unlock.log
   local log2=/data/local/tmp/script.log
   space="/data/superrepack" 
   current=${PWD}
   super=$(find_block -e super)
   [ -z "$1" ] && echo2 "unlock: Invalid line" && return 1
   [ -z "$super" ] && echo2 "unlock: CANT find super partition " && return 1
   delete_recursive "$space"
   delete "$log"
   mkdir -p "$space"
   if ! exist folder "$space"; then echo2 "super_rw: CANT make $space" && return 1; fi
   cd "$space"
   if is_number "$2"; then try="$2"; else try=5; fi
   startlog "$log"
   echolog '>>> Unlock On-Fly 1.0.0'
   echo2 " "
   echolog " -- Converting:$1 in $super to RW..."
   echolog " "
   while true; do
      result=
      sleep 1
      [[ "$count" == "$try" ]] && echolog "FATAL ERROR: CANT ENSURE $1 as RW with $count attemps" && return=1 && break
      echolog "unlock:Attempt: $count"
      count=$(($count + 1))
      superrepack "$super" "$1" >> "$log" 2>&1
      result=$?
      savelog "----------------script.log----------------"
      if exist "$log2"; then cat "$log2" >> "$log"; fi
      if [[ "$result" == "0" ]]; then
         if grep -q "Could not allocate block" "$log2"; then continue; else break; fi
      fi
   done
   cd "$current"
   delete_recursive "$space"
   return $return
}

superrepack() {
   local return=0
   ( delete "$TMP/vbmeta.img"
     write_raw_image "$(find_block -e vbmeta)" "$TMP/vbmeta.img") > /dev/null 2>&1
   if ! can_run superrepack; then echo2 "FATAL ERROR: CANT LOAD superrepack" && return=100; fi
   if [ "$return" != 100 ]; then "$l/superrepack" "$@"; return=$?; fi
   echo " -- Restoring vbmeta.img"
   is_valid "$TMP/vbmeta.img" && write_raw_image "$TMP/vbmeta.img" "$(find_block vbmeta)" > /dev/null 2>&1
   return $return
}

get_virtual_points() {
   local LOOP point try super
   super=$(find_block -e super)
   if undefined super && [ -z "$1" ]; then echo2 "CANT FIND SUPER PARTITION" && return 1
   elif [ -n "$1" ] && ! checksuper "$1"; then echo2 "FATAL ERROR: Invalid SUPER: $1" && return 1
   fi
   [ -n "$1" ] && super="$1"
   echo2 '-- Loading virtual points... '
   for point in system vendor product odm system_ext; do
      try="$point$slot"
      start_loop "$try" "$super" 2>/dev/null
      if defined LOOP; then all_looped_loop+=("$LOOP") && echo2 "$point=$LOOP" && setdefault "$point" "$LOOP"; else echo2 "NO POINT: $point "; fi
   done
}

get_size_ext4() { string inside ',' 'bytes' "$(fdisk -l "$1" | grep -m1 "Disk")" | tr -d " "; }

get_offset() {
  #get_offset "partition name inside SUPER" "SUPER partition/image"
  local head offset
  [ "$(superrepack teSt >/dev/null; echo $?)" == "100" ] && return 1
  [[ -z "$1" || -z "$2" ]] && return 1
  head=$(string -r -p "$1" complete_extract "partition_" "Partition:" "$(superrepack "$2" noneeded 2>/dev/null)")
  offset=$(string inside "offset =" ')' "$(echo "$head" | grep "dumping offset")" | tr -d " ")
  offset=$(printf "%d\n" "$offset" 2>/dev/null || echo FAILED)
  if ! is_substring "FAILED" "$offset"; then echo "$offset" && return 0; else return 1; fi
}

get_size() {
  #get_size "partition name inside SUPER" "SUPER partition/image"
  local head size
  [ "$(superrepack teSt >/dev/null; echo $?)" == "100" ] && return 1
  [[ -z "$1" || -z "$2" ]] && return 1
  head=$(string -r -p "$1" complete_extract "partition_" "Partition:" "$(superrepack "$2" noneeded 2>/dev/null)")
  size=$(string inside '(' 'bytes total' "$(echo "$head" | grep "bytes total")" | tr -d " ")
  size=$(printf "%d\n" "$size" 2>/dev/null || echo FAILED)
  if ! is_substring "FAILED" "$size"; then echo "$size" && return 0; else return 1; fi
}

get_total_size() {
  #get_total_size "SUPER partition/image"
  local head size bytes total=0 error=0
  [ "$(superrepack teSt >/dev/null; echo $?)" == "100" ] && return 1
  [ -z "$1" ] && return 1
  while read bytes; do
     undefined bytes && break
     size=$(string inside '(' 'bytes total' "$bytes" | tr -d " ")
     size=$(printf "%d\n" "$size" 2>/dev/null || echo FAILED)
     if ! is_substring "FAILED" "$size"; then total=$(calc $total + $size); else error=$(($error + 1)); fi
  done <<< $(superrepack "$1" noneeded 2>/dev/null | grep "bytes total")
  if [[ "$error" == "0" ]] && is_number "$total" && is_greater "$total" 0; then echo "$total" && return 0; else return 1; fi
}

get_group() {
  #get_group "partition name inside SUPER" "SUPER partition"
  local head group
  [ "$(superrepack teSt >/dev/null; echo $?)" == "100" ] && return 1
  [[ -z "$1" || -z "$2" ]] && return 1
  head=$(string -r -p "$1" complete_extract "partition_" "Partition:" "$(superrepack "$2" noneeded 2>/dev/null)")
  group=$(echo "$head" | grep "partition_group" | cut -d'=' -f2 | tr -d " ")
  if defined group; then echo "$group" && return 0; else return 1; fi
}

checksuper() {
  #checksuper "SUPER partition/image"
  [ "$(superrepack teSt >/dev/null; echo $?)" == "100" ] && return 1
  [ -z "$1" ] && return 1
  if ! superrepack >/dev/null "$1" noneeded 2>/dev/null | grep -q "This is not super image"; then true; else false; fi
}

start_loop() {
    local loop=$(losetup2 -f) size offset
    [ "$(superrepack teSt >/dev/null; echo $?)" == "100" ] && return 1
    if ! can_run losetup2; then echo2 "FATAL ERROR: CANT LOAD losetup2" && return 1; fi
    if undefined loop; then echo2 "Cant make loop" && return 1; fi
    if ! checksuper "$2"; then echo2 "start_loop: Invalid SUPER: $2" && return 1; fi
    size=$(get_size "$1" "$2")
    offset=$(get_offset "$1" "$2")
    if ! defined size offset || ! is_number "$size" || ! is_number "$offset"; then echo2 "CANT GET INFO FROM: $2" && return 1; fi
    losetup2 --offset=$offset --sizelimit=$size $loop "$2"
    if losetup2 -a | grep -q "$loop"; then all_loopkskqiiq+=("$loop") && echo2 "$loop" && LOOP="$loop"; else return 1; fi
}

end_loop() {
   local i refresh
   LOOP=
   [[ -z "${all_loopkskqiiq[${#all_loopkskqiiq[@]} - 1]}" && -z "$1" ]] && return 1
   if [ -z "$1" ]; then
      losetup -d "${all_loopkskqiiq[${#all_loopkskqiiq[@]} - 1]}"
      unset "all_loopkskqiiq[${#all_loopkskqiiq[@]}-1]"
      for i in "${!all_loopkskqiiq[@]}"; do
         refresh+=("${all_loopkskqiiq[i]}")
      done
      all_loopkskqiiq=("${refresh[@]}")
   else
      losetup -d "$1"
   fi
}

unify_path() {
   local check eq1 eq2 only return=0
   touch "$2/testrw" 2>/dev/null
   if exist "$2/testrw"; then
      delete "$2/testrw"
   else
      echo "unify_path: $2 Read/Only or Invalid" && return 1
   fi
   while read check; do
      if is_substring " differ" "$check"; then
         eq1=$(string inside "Files " " and" "$check")
         eq2=$(string inside " and " " differ" "$check")
         if defined eq1 eq2 && exist "$eq1" "$eq2"; then
            echo2 "Replacing: $eq1 in $eq2"
            if ! copy "$eq1" "$eq2"; then echo2 "FATAL ERROR: Cant unify $eq1" && return=1; fi
         fi
      elif is_substring "Only in $1" "$check"; then
         only=$(string remove "Only in $1: " "$check")
         if defined only && exist "$1/$only"; then
            echo2 "Adding: $1/$only in $2/$only"
            if ! copy "$1/$only" "$2/$only"; then echo2 "FATAL ERROR: Cant unify $1/$only" && return=1; fi
         fi
      fi
   done <<< $(diff -qr "$1" "$2")
   return $return
}

super_rw() {
   #super_rw for Dynamic Installer by @BlassGO
   #superunpack by @munjeni
   #Inspired on @lebigmac systemrw project
   ui_print " "
   ui_print " Oops! "
   ui_print " super_rw function was discontinued, its effectiveness is not good on all devices"
   ui_print " "
   return
   [ "$(superrepack teSt >/dev/null; echo $?)" == "100" ] && return 1
   if ! can_run superunpack; then ui_print "FATAL ERROR: CANT LOAD superunpack" && return 1; fi
   if ! can_run losetup2; then ui_print "FATAL ERROR: CANT LOAD losetup2" && return 1; fi
   local try count return=0 result block size size512 part newsize error reference all_blocks
   local restore flag force boot extract baseblock add add2 try in in2 custom custom512 test loop needed total free super LOOP nw
   local current=${PWD}
   local log=/data/super_rw.log
   local log2=/data/super_rw.tmp
   local space="/data/super_rw"
   local extra_space=100
   restore=()
   while [[ $# -gt 0 ]]; do
     flag="$1"
     case $flag in
         -f|-force)
         force=true
         shift
         ;;
         -nw|-no-wipe)
         nw=true
         shift
         ;;
         -b|-bootmode)
         boot=true
         shift
         ;;
         -s|-super)
         super="$2"
         shift;shift;
         ;;
         -a|-add)
         if is_substring "MB" "$2"; then add=$(string remove MB "$2" | awk '{print int($1 * 1024 * 1024)}'); else add="$2"; fi
         if ! is_number "$2" && ! is_greater "$2" 0; then ui_print "super_rw: Invalid line" && return 1; fi
         shift;shift;
         ;;
         -ai|-add-in)
         if [[ -z "$2" || -z "$3" ]]; then ui_print "super_rw: Invalid line" && return 1; fi
         in+=("$2")
         if is_substring "MB" "$3"; then
            test=$(string remove MB "$3" | awk '{print int($1 * 1024 * 1024)}')
            if is_number "$test" && is_greater "$test" 0; then in2+=("$test"); else ui_print "super_rw: Invalid line" && return 1; fi
         elif is_number "$3" && is_greater "$3" 0; then
            in2+=("$3")
         else
            ui_print "super_rw: Invalid line" && return 1
         fi
         shift;shift;shift;
         ;;
         *)   
         restore+=("$1")
         shift
         ;;
     esac
   done
   set -- "${restore[@]}"
   [ -z "$super" ] && super=$(find_block -e super)
   [ -z "$super" ] && ui_print "super_rw: CANT find super partition " && return 1
   if ! checksuper "$super"; then ui_print "super_rw: Invalid SUPER: $super" && return 1; fi
   delete_recursive "$space"
   delete "$log"
   mkdir -p "$space"
   if ! exist folder "$space"; then ui_print "super_rw: CANT make $space" && return 1; fi
   cd "$space"
   startlog "$log"
   printlog '>>> Super_rw 1.0.0'
   #Mb to Bytes
   extra_space=$(calc $extra_space '* (1024^2)')
   #Total bytes + extra bytes
   total=$(calc $(get_total_size "$super") + $extra_space)
   #Bytes to GB
   needed=$(calc $total / '(1024^3)' )
   #Get free Kilobytes in space
   free=$(df -P "$space" | tail -1 | awk '{print $4}')
   #Kilobytes to GB
   free=$(calc $free / '(1024^2)')
   printlog " "
   printlog "super: $super "
   printlog "free_space: $free GB"
   printlog "needed_space: $needed GB"
   printlog " "
   #Check space
   if ! is_greater "$free" "$needed"; then printlog "super_rw: NO free space to extract SUPER image" && return 1; fi
   if undefined boot && $BOOTMODE && grep -q "^super_rw" "$TMP/updater-script" > /dev/null 2>&1; then
     ui_print " "
     ui_print "DI: Please install this ZIP with a Custom Recovery"
     ui_print "DI: This will allow the installer to unlock your partitions"
     ui_print " "
     $custom_mode && return 1 || abort
   elif undefined boot && $BOOTMODE; then
     ui_print " "
     ui_print "DI: Please add super_rw in the updater-script"
     ui_print "DI: Then install the ZIP with a Custom Recovery"
     ui_print "DI: This will allow the installer to unlock your partitions"
     ui_print " "
     $custom_mode && return 1 || abort
   fi
   printlog " -- Extracting:$super in $space..."
   superunpack "$super" 1 >> "$log" 2>&1
   while read part; do
         if undefined part; then printlog "FATAL ERROR: CANT FIND EXTRACTED IMGs" && break; fi
         count=0
         error=0
         size=
         size512=
         custom=
         custom512=
         baseblock=
         add2=
         baseblock=$(string remove ".ext4" "$(basename "$part")")
         if undefined baseblock; then printlog "FATAL ERROR: Cant get valid info from $part" && continue; fi
         if is_substring "shared_blocks" "$(tune2fs -l "$part" | grep "features")" || defined force; then
            printlog " -- Converting:$baseblock to RW..."
            size=$(get_size_ext4 "$part")
            size512=$(calc $size / 512)
            undefined size size512 && printlog "cant get size: $part" && continue
            printlog "$baseblock:size: $size"
            printlog "$baseblock:size512: $size512"
            newsize=$(calc '('$size' * 1.25) / 512')
            savelog "CALCULATED:$newsize"
            if ! resize2fs -f "$part" $newsize"s" >> "$log" 2>&1; then error=$(($error + 1)) && printlog "some error: resizing $part"; fi
            savelog " UNSHARING BLOCKS "
            e2fsck -y -E unshare_blocks "$part" >> "$log" 2>&1
            if is_substring "shared_blocks" "$(tune2fs -l "$part" | grep "features")"; then error=$(($error + 1)) && printlog "some error: unsharing block $part"; fi
            savelog " SHRINKING: MINIMUN SIZE"
            if ! resize2fs -f -M "$part" >> "$log" 2>&1; then error=$(($error + 1)) && printlog "some error: shrinking $part"; fi
            if is_less "$(get_size_ext4 "$part")" "$size"; then
               savelog " RESTORING SIZE "
               if ! resize2fs -f "$part" $size512"s" >> "$log" 2>&1; then error=$(($error + 1)) && printlog "some error: resizing $part"; fi
            fi
            if defined add; then
               size=$(get_size_ext4 "$part")
               custom=$(calc $size + $add)
               custom512=$(calc $custom / 512)
               printlog "$baseblock:custom_size: $custom"
               printlog "$baseblock:custom_size512: $custom512"
               if ! resize2fs -f "$part" $custom512"s" >> "$log" 2>&1; then error=$(($error + 1)) && printlog "some error: resizing $part"; fi
            fi
            if defined in; then
               for i in "${!in[@]}"; do
                  if is_substring "${in[i]}" "$baseblock"; then add2=${in2[i]} && break; fi
               done
               if defined add2; then
                  size=$(get_size_ext4 "$part")
                  custom=$(calc $size + $add2)
                  custom512=$(calc $custom / 512)
                  printlog "$baseblock:custom_size: $custom"
                  printlog "$baseblock:custom_size512: $custom512"
                  if ! resize2fs -f "$part" $custom512"s" >> "$log" 2>&1; then error=$(($error + 1)) && printlog "some error: resizing $part"; fi
               fi
            fi
            savelog " EXTRA FIX"
            e2fsck -fy "$part" >> "$log" 2>&1
            start_loop "$baseblock" "$super"
            loop="$LOOP"
            if ! defined loop; then echolog "some error: looping $block" && continue; fi
            printlog "$baseblock:loop: $loop"
            printlog " -- Unifying:$baseblock with $loop"
            try_mount -f "$loop" /mnt/stock_part
            try_mount -f "$part" /mnt/new_part
            if [ -z "$(ls -A /mnt/stock_part)" ]; then printlog "Cant mount: /mnt/stock_part" && continue; fi
            if [ -z "$(ls -A /mnt/new_part)" ]; then printlog "Cant mount: /mnt/new_part" && continue; fi
            if ! unify_path /mnt/stock_part /mnt/new_part >> "$log" 2>&1; then error=$(($error + 1)) && printlog "some error: unifying $part"; fi
            unmount /mnt/stock_part
            unmount /mnt/new_part
            printlog " -- Updating:$baseblock..."
            dd if="$part" of="$loop" bs=1M >> "$log" 2>&1
            losetup2 -c "$loop" >> "$log" 2>&1
            savelog " FINISHING"
            ( blockdev --setrw "$loop"
            end_loop "$loop" ) >> "$log" 2>&1
            size=$(get_size_ext4 "$part")
            size512=$(calc $size / 512)
            printlog "$baseblock:newsize: $size"
            printlog "$baseblock:newsize512: $size512"
            printlog "$baseblock:ended_with_error:$error"
            savelog "$(tune2fs -l "$part" | grep "features")"
            if [[ "$error" != "0" ]]; then return=1; fi
            printlog " "
        else
            printlog " -- Skipping:$baseblock..." && continue
        fi
        echo2 " "
   done <<< $(find "$space" -mindepth 1 -maxdepth 1 -type f -name "*.ext4")
   cd "$current"
   if [ -z "$nw" ]; then
      savelog " -- Wiping..."
      delete_recursive "$space"
   fi
   endlog
   return $return
}

ensure_root() {
   local fail=0
   free_root=$((df -Pk / | sed "1d" | awk '{print $4}') 2>/dev/null)
   free_system=$((df -Pk /system | sed "1d" | awk '{print $4}') 2>/dev/null)
   free_vendor=$((df -Pk /vendor | sed "1d" | awk '{print $4}') 2>/dev/null)
   [ -n "$free_root" ] && free_root=$(calc ${free_root} '*' 1024)
   [ -n "$free_system" ] && free_system=$(calc ${free_system} '*' 1024)
   [ -n "$free_vendor" ] && free_vendor=$(calc ${free_vendor} '*' 1024)
   if is_number "$free_root" && ! is_greater "$free_root" "6144"; then
      ui_print " "
      ui_print 'DI: Oops! Your free space in root "/" is not enough to perform any basic operation'
      ui_print " "
      abort " "
   fi
   if is_number "$free_system" && ! is_greater "$free_system" "10485760"; then
      echo2 " "
      echo2 'DI: The free space in "system" is very low (Less than or equal to 10MB), I recommend you check the changes that required more free space'
      echo2 " "
   fi
   mount -o rw,remount -t auto / 2>/dev/null
   try_mount -rw -n system /system_root
   is_mounted /system_root && touch /system_root/rwtest
   if exist /system_root/rwtest /system_root/etc; then delete /system_root/rwtest && return; fi
   if [[ "$virtual_partitions" == "true" ]]; then
      ui_print " "
      ui_print 'DI: Virtual partitions (Read/Only)...'
      ui_print "DI: Your current SYSTEM.img are locked..."
      ui_print 'DI: You need to use a ROM/GSI that supports mounting as Read/Write'
      ui_print " "
      abort " "
   fi
   #Check rw (in case manual mode is changed to automatic)
   try_mount -rw -n system /system_root
   is_mounted /system_root && touch /system_root/rwtest
   if exist /system_root/rwtest /system_root/etc; then
      delete /system_root/rwtest && return
   else
      echo2 " ENSURE_ROOT: FAILED " && return 1
   fi
}

mount_all() { auto_mount_partitions; }

mount_all_old() {
  local runtime dest part block bind
  if ! is_mounted /data; then
     mount /data
    UMOUNT_DATA=1
  fi
  #Ensure root space
  mount -o rw,remount -t auto / 2>/dev/null
  (mount /cache
  mount -o ro -t auto /persist
  mount -o ro -t auto /product
  mount -o ro -t auto /vendor
  mount -o ro -t auto /odm
  mount -o ro -t auto /system_ext) 2>/dev/null
  setup_mountpoint $ANDROID_ROOT
  if ! is_mounted $ANDROID_ROOT; then
    mount -o ro -t auto $ANDROID_ROOT 2>/dev/null
  fi
  case $ANDROID_ROOT in
    /system_root) setup_mountpoint /system;;
    /system)
      if ! is_mounted /system && ! is_mounted /system_root; then
        setup_mountpoint /system_root
        mount -o ro -t auto /system_root
      elif [ -f /system/system/build.prop ]; then
        setup_mountpoint /system_root
        mount --move /system /system_root
      fi
      if [ $? != 0 ]; then
        umount /system
        umount -l /system 
        if [ "$dynamic_partitions" = "true" ]; then
          mount -o ro -t auto /dev/block/mapper/system$slot /system_root
          for part in system_ext vendor product odm; do
             block=/dev/block/mapper/$part$slot
             if [ -e $block ]; then
                [ -d /$part ] || mkdir -p /$part
                mount -o ro -t auto $block /$part
             fi
          done
        else
          mount -o ro -t auto /dev/block/bootdevice/by-name/system$slot /system_root
        fi
      fi
    ;;
  esac
  if is_mounted /system_root; then
    if [ -f /system_root/build.prop ]; then
      echo2 " Mounting:bind: /system_root /system"
      mount -o bind /system_root /system
      contains_array "/system" "${all_binded_part[@]}" || all_binded_part+=("/system")
    else
      echo2 " Mounting:bind: /system_root/system /system"
      mount -o bind /system_root/system /system
      contains_array "/system" "${all_binded_part[@]}" || all_binded_part+=("/system")
    fi
    for bind in /system/system_ext /system/product /system/vendor; do
       if [ ! -L "$bind" ]; then
         echo2 " Mounting:bind: $bind /$(basename "$bind")"
         setup_mountpoint "/$(basename "$bind")"
         mount -o bind "$bind" "/$(basename "$bind")"
         contains_array "/$(basename "$bind")" "${all_binded_part[@]}" || all_binded_part+=("/$(basename "$bind")")
       fi
    done
  fi
  if is_mounted /vendor; then
     for bind in /vendor/odm; do
       if [ ! -L "$bind" ]; then
         echo2 " Mounting:bind: $bind /$(basename "$bind")"
         setup_mountpoint "/$(basename "$bind")"
         mount -o bind "$bind" "/$(basename "$bind")"
         contains_array "/$(basename "$bind")" "${all_binded_part[@]}" || all_binded_part+=("/$(basename "$bind")")
       fi
    done
  fi
}

umount_all() {
  local part umount post extra result=0 loop restore simple_umt
  (if $BOOTMODE; then
     for umount in /system_ext /vendor /product /odm; do
         if ! contains_array "$umount" "${all_umount[@]}"; then all_umount+=("$umount"); fi
     done
     for simple_umt in "${all_binded_part[@]}"; do
        echo2 " Unmounting $simple_umt "
        umount -l "$simple_umt" 2>/dev/null
     done
     echo2 " Unmounting /system_root "
     unmount /system_root || unmount /system_root
     if is_mounted /system_root; then echo2 " CANT UNMOUNT: /system_root" && result=1; fi
     for loop in "${all_looped[@]}"; do
       echo2 " Unmounting $loop "
       umount -ld "$loop" 2>/dev/null
       if is_mounted "$loop"; then echo2 " CANT UNMOUNT: $loop" && result=1; fi
     done
     for loop in "${all_looped_loop[@]}"; do
       losetup -d "$loop" 2>/dev/null
     done
     for part in "${all_umount[@]}"; do
        if is_mounted "$part"; then
           try_mount -ro "$part" || try_mount -remount -ro "$part" || echo2 " CANT REMOUNT: $part as RO "
        fi
     done
     for restore in "${all_umount[@]}" "${all_looped[@]}"; do
       if [ -L "${restore}_link" ]; then
          rmdir "$restore"
          mv -f "${restore}_link" "$restore"
       fi
     done
  else
     for umount in /system_ext /system /system_root /cache /persist /vendor /product /odm; do
         if ! contains_array "$umount" "${all_umount[@]}"; then all_umount+=("$umount"); fi
     done
     if $APEX_MOUNT_PASS; then umount_apex; export APEX_MOUNT_PASS=false; fi
     for simple_umt in "${all_binded_part[@]}"; do
        umount -l "$simple_umt" 2>/dev/null
     done
     for part in "${all_umount[@]}"; do
       echo2 " Unmounting $part "
       unmount "$part" || post+=("$part")
     done
     for loop in "${all_looped[@]}"; do
       echo2 " Unmounting $loop "
       umount -ld "$loop" 2>/dev/null || post+=("$loop")
     done
     for loop in "${all_looped_loop[@]}"; do
       losetup -d "$loop" 2>/dev/null
     done
     for extra in "${post[@]}"; do
        unmount "$extra"
        if is_mounted "$extra"; then echo2 " CANT UNMOUNT: $extra" && result=1; fi
     done
     for restore in /apex "${all_umount[@]}" "${all_looped[@]}"; do
       if [ -L "${restore}_link" ]; then
          rmdir "$restore"
          mv -f "${restore}_link" "$restore"
       fi
     done
  fi
  mount -o rw,remount -t auto / 2>/dev/null
  if $BOOTMODE; then is_mounted /system_root || rm -rf /system_root; fi
  $BOOTMODE && mount -o ro,remount -t auto / 2>/dev/null
  if [ "$UMOUNT_DATA" ]; then
    umount /data
    umount -l /data
  fi)
  $BOOTMODE || umount -l /dev/random 2>/dev/null
  unset all_binded_part all_umount all_looped all_looped_loop
  return $result
}

destroy_env() {
   [ -z "$OLD_LD_PATH" ] && OLD_LD_PATH="$LD_LIBRARY_PATH"
   [ -z "$OLD_LD_PRELOAD" ] && OLD_LD_PRELOAD="$LD_PRELOAD"
   [ -z "$OLD_LD_CONFIG" ] && OLD_LD_CONFIG="$LD_CONFIG_FILE"
   unset LD_LIBRARY_PATH
   unset LD_PRELOAD
   unset LD_CONFIG_FILE
}

restore_env() {
  [ -n "$OLD_LD_PATH" ] && export LD_LIBRARY_PATH="$OLD_LD_PATH"
  [ -n "$OLD_LD_PRELOAD" ] && export LD_PRELOAD="$OLD_LD_PRELOAD"
  [ -n "$OLD_LD_CONFIG" ] && export LD_CONFIG_FILE="$OLD_LD_CONFIG"
}

dynamic_install(){
   local f inst_dir origin
   origin=$(readlink -f "$1")
   [ ! -d "$origin" ] && return 1
   while read f; do
     undefined f && break
     inst_dir=${f/"$origin"/"$2"}
     if [ -d "$f" ]; then
        if [ ! -d "$inst_dir" ]; then mkdir -p "$inst_dir"; set_perm2 0 0 $di_perm_d "$inst_dir"; fi
        continue
     fi
     inject "$f" "$(dirname "$inst_dir")"
   done <<< $(find "$origin" -mindepth 1)
}
	
inject() {
  local file dest return=0
  file=$(basename "$1")
  dest="$2/$file"
  [ ! -f "$1" ] && return 1
  if [ ! -d "$2" ]; then mkdir -p "$2"; fi
  if install -D "$1" "$dest" >/dev/null 2>&1; then
     set_perm2 0 0 $di_perm_f "$dest"
     set_perm2 0 0 $di_perm_d "$2"
  elif cp -prf "$1" "$dest"; then
     set_perm2 0 0 $di_perm_f "$dest"
     set_perm2 0 0 $di_perm_d "$2"
  else
     echo2 "Cant inject: $file" && return=1
  fi
  return $return
}

auto_mount_partitions() {
    local main block extra noexist bind
    if ! $BOOTMODE; then
      mount -o bind /dev/urandom /dev/random
      umount_all
      mount_all_old
    fi
    if [ "$dynamic_partitions" = "true" ]; then
       find /dev/block/mapper -mindepth 1 -maxdepth 1 \( -type b -o -type c -o -type l \) | while read block; do
          if undefined block; then echo2 "WARNING: CANT FIND /dev/block/mapper partitions" && break; fi
          blockdev --setrw "$block"
       done
    fi
    #Ensure root space
    ensure_root
    if $BOOTMODE; then
       if ! is_mounted /system_root; then
          try_mount -n system /system_root
       fi
       if is_mounted /system_root; then
          if [ -f /system_root/build.prop ]; then
            echo2 " Mounting:bind: /system_root /system"
            mount -o bind /system_root /system
            contains_array "/system" "${all_binded_part[@]}" || all_binded_part+=("/system")
          else
            echo2 " Mounting:bind: /system_root/system /system"
            mount -o bind /system_root/system /system
            contains_array "/system" "${all_binded_part[@]}" || all_binded_part+=("/system")
          fi
          for bind in /system/system_ext /system/product /system/vendor; do
             if [ ! -L "$bind" ]; then
               echo2 " Mounting:bind: $bind /$(basename "$bind")"
               mount -o bind "$bind" "/$(basename "$bind")"
               contains_array "/$(basename "$bind")" "${all_binded_part[@]}" || all_binded_part+=("/$(basename "$bind")")
             fi
          done
       else
          echo2 " CANT ENSURE: /system_root "
       fi
       for extra in system_ext vendor product odm; do
          if ! contains_array "/$extra" "${all_binded_part[@]}" && exist $(find_block -e $extra); then
             try_mount "/$extra" || try_mount -remount "/$extra"
          fi
       done
       if is_mounted /vendor; then
          for bind in /vendor/odm; do
            if [ ! -L "$bind" ]; then
              echo2 " Mounting:bind: $bind /$(basename "$bind")"
              setup_mountpoint "/$(basename "$bind")"
              mount -o bind "$bind" "/$(basename "$bind")"
              contains_array "/$(basename "$bind")" "${all_binded_part[@]}" || all_binded_part+=("/$(basename "$bind")")
            fi
         done
       fi
    else
       for main in system system_ext vendor product odm; do
          if ! is_mounted "/$main"; then
             if [[ "$main" == "system" ]]; then 
                try_mount -remount -n system /system_root
                if is_mounted /system_root; then
                   setup_mountpoint /system
                   if [ -f /system_root/build.prop ]; then
                      echo2 " Mounting:bind: /system_root /system"
                      mount -o bind /system_root /system
                      contains_array "/system" "${all_binded_part[@]}" || all_binded_part+=("/system")
                   else
                      echo2 " Mounting:bind: /system_root/system /system"
                      mount -o bind /system_root/system /system
                      contains_array "/system" "${all_binded_part[@]}" || all_binded_part+=("/system")
                   fi
                   for bind in /system/system_ext /system/product /system/vendor; do
                      if [ ! -L "$bind" ]; then
                        echo2 " Mounting:bind: $bind /$(basename "$bind")"
                        setup_mountpoint "/$(basename "$bind")"
                        mount -o bind "$bind" "/$(basename "$bind")"
                        contains_array "/$(basename "$bind")" "${all_binded_part[@]}" || all_binded_part+=("/$(basename "$bind")")
                      fi
                   done
                else
                   echo2 " CANT ENSURE: /system_root "
                fi
             else
                if exist $(find_block -e $main); then
                   contains_array "/$main" "${all_binded_part[@]}" || try_mount -remount "/$main"
                else
                   noexist+=("$main")
                fi
             fi
             if contains_array "$main" "${noexist[@]}"; then
                echo2 " No block: $main "
             elif ! is_mounted "/$main"; then
                echo2 " CANT MOUNT: /$main "
             fi
          else
             echo2 " Mounted:main: /$main"
          fi
       done
       if is_mounted /vendor; then
          for bind in /vendor/odm; do
            if [ ! -L "$bind" ]; then
              echo2 " Mounting:bind: $bind /$(basename "$bind")"
              setup_mountpoint "/$(basename "$bind")"
              mount -o bind "$bind" "/$(basename "$bind")"
              contains_array "/$(basename "$bind")" "${all_binded_part[@]}" || all_binded_part+=("/$(basename "$bind")")
            fi
         done
       fi
    fi
    if [[ -n "$apex_mount" && "$apex_mount" != "off" ]]; then 
       $BOOTMODE || mount_apex
    elif ! $BOOTMODE; then
       runtime=$(find /system/apex -name "com.android.runtime*" -print | head -n 1)
       [[ -z "$runtime" && -d /system_ext/apex ]] && runtime=$(find /system_ext/apex -name "com.android.runtime*" -print | head -n 1)
       if [ -z "$runtime" ]; then echo2 "FATAL ERROR: Cant find RUNTIME"
       else apex_mount "$runtime"
       fi
    fi
    ( mount -o rw,remount -t auto /system || mount -o rw,remount -t auto /
    mount -o rw,remount -t auto /vendor 
    mount -o rw,remount -t auto /product
    mount -o rw,remount -t auto /odm
    mount -o rw,remount -t auto /system_ext ) 2>/dev/null
    #Extra RW for /system_root
    mount -o remount,rw /system_root
}
if [ -z "$BOOTMODE" ]; then
   ps | grep zygote | grep -qv grep && export BOOTMODE=true || export BOOTMODE=false
   $BOOTMODE || ps -A 2>/dev/null | grep zygote | grep -qv grep && export BOOTMODE=true
fi
test "$ANDROID_ROOT" || ANDROID_ROOT=/system
getarch

export APEX_MOUNT_PASS=false
export custom_mode=false
export n='
'
export yes=chooseport
export MYPATH="$1"

#Recovery Mode + Test Mode Implementation
#(Maintenance or just testing for Devs)
if [[ -z "$installzip" && "$BOOTMODE" == "false" ]]; then
   export custom_mode=true
   export apex_mount=true
   echo " >> Recovery Mode 1.1.0 "
   echo " @BlassGO "
   echo " "
   defined MYPATH && echo " -- Working from: $MYPATH"
   echo " -- Loading environment..."
   echo
elif [[ -z "$installzip" && "$BOOTMODE" == "true" ]]; then
   export custom_mode=true
   export PATH="/data/data/com.termux/files/usr/bin:/data/data/com.termux/files/usr/bin/applets:/sbin:/sbin/su:/su/bin:/su/xbin:/system/bin:/system/xbin:$PATH"
   echo " >> Test Mode 1.7.0 "
   echo " @BlassGO "
   echo " "
   defined MYPATH && echo " -- Working from: $MYPATH"
   echo " -- Loading environment..."
   echo
fi

#CUSTOM MODES (Generic Setup)
if [[ "$custom_mode" == "true" ]]; then
   setenforce 0 2>/dev/null
   
   #Global vars
   if defined TMPDIR Dynamic_Setup; then export TMP="$TMPDIR"
   elif ! $BOOTMODE && [ -d /tmp ]; then export TMP=/tmp
   elif [ -d /data ] && mkdir -p /data/tmp && [ -d /data/tmp ]; then export TMP=/data/tmp
   else export TMP=/dev/tmp
   fi
   if undefined TMP; then echo2 "FATAL ERROR: Cant start TMP" && exit 1; fi
   export l="$TMP/ugu"
   export addons="$TMP/addons"
   bb="$TMP/busybox"
   bin="$TMP/bin.xz"
   extra="$TMP/extra.zip"
   
   #Remove only zbin plugins
   ( rm -rf "$l" "$TMP/zbin"
     rm -f "$bb" "$TMP/bin" "$bin" "$extra" "$TMP/core"
   ) 2>/dev/null
   
   #Create work DIRs
   mkdir -p "$l"
   mkdir -p "$TMP/zbin"
   if [ ! -d "$l" ] || [ ! -d "$TMP/zbin" ]; then
     echo "ERROR: Cant startup"
     exit 1
   fi
   
   #Getting zbin plugins
   if exist "$MYPATH/busybox" "$MYPATH/bin"; then
      copy "$MYPATH/bin" "$bin"
      copy "$MYPATH/busybox" "$bb"
   elif exist busybox bin; then
      copy busybox "$bb"
      copy bin "$bin"
   else
      echo "ERROR: CANT FIND BUSYBOX or BIN"
      exit 1
   fi
   
   #Getting extra.zip (Optional)
   if exist "$MYPATH/extra.zip"; then
      copy "$MYPATH/extra.zip" "$extra"
   elif exist extra.zip; then
      copy extra.zip "$extra"
   fi
   
   #Getting file_types.config (Optional)
   if exist "$MYPATH/configs/file_types.config"; then
      copy "$MYPATH/configs/file_types.config" "$l"
   elif exist configs/file_types.config; then
      copy configs/file_types.config "$l"
   fi
   
   #Getting units.config (Optional)
   if exist "$MYPATH/configs/units.config"; then
      copy "$MYPATH/configs/units.config" "$l"
   elif exist configs/units.config; then
      copy configs/units.config "$l"
   fi
   
   #Permissions
   chmod 755 "$bb" "$bin" "$extra" 2>/dev/null
   
   #First ensuring Busybox environment
   setup_bb
   export PATH="$l:$PATH"
   
   #Loading bin
   xz -d "$bin" >/dev/null 2>&1
   if [ ! -f "$TMP/bin" ]; then echo "CANT EMULATE BIN" && exit 1; fi;
   unzip -qo "$TMP/bin" -d "$TMP/zbin"
   import_info "$TMP/zbin/info.txt"
  
   #Loading extra.zip (Optional)
   if [ -f "$TMP/extra.zip" ]; then
      unzip -qo "$TMP/extra.zip" -d "$TMP/zbin"
      import_info "$TMP/zbin/info.txt"
   fi
  
   #Finish
   find "$TMP/zbin" -type f -exec mv -f {} "$l" \;
   find "$l" -type f -exec chmod 755 {} +;
fi

#Get AVB state
#getsecurity

#Checking TMP2 (For Dual functions operations)
start_tmp
if [ ! -d "$TMP2" ]; then abort "CANT SETUP: TMP2"; fi
tmp2="$TMP2"
end_tmp
if [ -d "$tmp2" ]; then abort "CANT SETUP:2: TMP2"; fi
unset tmp2

#Extra environment vars
export di_apex_list="$TMP/apex_list_0001.txt"
setdefault permissions "0755:0777"

#Checking possible exceptions (Read/Only Functions)
pattern=off_readonly
eval "$pattern() { :; }"
if defined installzip; then
   while read ole; do
      undefined ole && break
      exception+=("$ole")
   done <<< $(split_string " " "$(string -r remove "$pattern " "$(
   package_extract_file META-INF/com/google/android/updater-script | grep "^$pattern "
   package_extract_file META-INF/com/google/android/magisk/customize.sh | grep "^$pattern "
   package_extract_file META-INF/com/google/android/magisk/install.sh | grep "^$pattern "
   )" 2>/dev/null
   )"
   )
fi
unset pattern ole

if ! $custom_mode; then
   #Ensuring Dynamic Installer functions
   for func in $(declare -F 2>/dev/null | awk '{ print $3; }'); do
      if contains_array "$func" "${exception[@]}" 2>/dev/null; then echo2 "readonly:off: $func"; else readonly -f $func 2>/dev/null; fi
   done
   unset func

   #Ensuring Dynamic Installer vars
   vars="TMP TMPDIR OUTFD installzip addons l n yes di_apex_list"
   for var in $vars; do
      if contains_array "$var" "${exception[@]}" 2>/dev/null; then echo2 "readonly:off: $var"; else undefined $var || readonly $var 2>/dev/null; fi
   done
fi
unset vars var exception

#Load Virtual points
#get_virtual_points

#Destroy Recovery env
$BOOTMODE || destroy_env

#Check Custom Mode
if $custom_mode; then return; fi

# Pre-setup
package_extract_file META-INF/com/google/android/updater-script "$TMP/updater-script"
package_extract_dir META-INF/addons "$addons"
package_extract_dir META-INF/zbin/configs "$l"
chmod 755 "$TMP/updater-script"
devices=$(getdefault "$TMP/updater-script" devices)
apex_mount=$(getdefault "$TMP/updater-script" apex_mount)
magisk_support=$(getdefault "$TMP/updater-script" magisk_support)
extraction_speed=$(getdefault "$TMP/updater-script" extraction_speed)
permissions=$(getdefault "$TMP/updater-script" permissions)
if [[ -n "$devices" && "$devices" != "off" ]]; then
    dcount=0
    setdefault may "
    $(getprop ro.product.device 2>/dev/null) 
    $(getprop ro.build.product 2>/dev/null) 
    $(getprop ro.product.vendor.device 2>/dev/null) 
    $(getprop ro.vendor.product.device 2>/dev/null)
    $(get_file_prop /default.prop ro.product.device 2>/dev/null)
    $(getprop ro.product.model 2>/dev/null) 
    $(grep_cmdline androidboot.em.model 2>/dev/null) 
    "
    while read huh; do
       undefined huh && continue
       while read ugu; do
         undefined ugu && continue
         if [[ "$huh" == "$ugu" ]]; then
            dcount=$(($dcount + 1))
            echo2 "[$ugu] == [$huh]"
         else
            echo2 "[$ugu] != [$huh]"
         fi
       done <<< $(split_string '' "$may")
    done <<< $(split_string : "$devices")
    if [[ "$dcount" == "0" ]]; then abort " -- Incompatible device: Its only for $(string force -r replace : ' and ' "$devices")"; fi;
fi
unset may huh ugu dcount

#Ensure/Check new default permissions
setdefault permissions "$permissions"

if $BOOTMODE && [[ "$magisk_support" != "on" ]]; then
   if ! exist "$TMP"; then abort "FATAL ERROR: Cant find $TMP"; fi
   echo2 "----------------Running SCRIPTs------------"
   . "$TMP/updater-script"
   if [[ "$run_addons" == "on" ]]; then
     while read addon; do
        if exist "$addon"; then . "$addon"; fi
     done <<< $(find "$addons" -mindepth 1 -maxdepth 1 -type f -name "*.sh")
   fi
   remove_tmp
   echo2 "-------------------------------------------"
   exit 0
fi

if ! $BOOTMODE; then
echo2 "----------------Running SCRIPTs------------"
. "$TMP/updater-script"
if [[ "$run_addons" == "on" ]]; then
    while read addon; do
       if exist "$addon"; then . "$addon"; fi
    done <<< $(find "$addons" -mindepth 1 -maxdepth 1 -type f -name "*.sh")
fi
remove_tmp
restore_env
echo2 "-------------------------------------------"

else

require_new_magisk() {
    ui_print "*******************************"
    ui_print " Please install Magisk v19.0+! "
    ui_print "*******************************"
    abort
}

magisk_print() {
  ui_print "----------------------------------------"
  ui_print ' >>> Powered by Magisk '$MAGISK_VER_CODE
  ui_print "----------------------------------------"
  ui_print " "
}

mount /data 2>/dev/null

[ -f /data/adb/magisk/util_functions.sh ] || require_new_magisk
. /data/adb/magisk/util_functions.sh
[ $MAGISK_VER_CODE -lt 19000 ] && require_new_magisk

is_legacy_script() {
  unzip -l "$ZIPFILE" $DNM/install.sh | grep -q install.sh
  return $?
}

setup_flashable() {
  $BOOTMODE && return
  if [ -z $OUTFD ] || readlink /proc/$$/fd/$OUTFD | grep -q /tmp; then
    # We will have to manually find out OUTFD
    for FD in `ls /proc/$$/fd`; do
      if readlink /proc/$$/fd/$FD | grep -q pipe; then
        if ps | grep -v grep | grep -qE " 3 $FD |status_fd=$FD"; then
          OUTFD=$FD
          break
        fi
      fi
    done
  fi
  recovery_actions
}


install_module() {
  
  cd $TMPDIR

  setup_flashable
  mount_partitions
  api_level_arch_detect
  
  # Setup busybox and binaries
  if $BOOTMODE; then
    boot_actions
  else
    recovery_actions
  fi
  
  # Extract prop file
  package_extract_file $DNM/module.prop $TMPDIR/module.prop
  [ ! -f $TMPDIR/module.prop ] && abort "! Unable to extract zip file!"
  
  local MODDIRNAME=modules
  $BOOTMODE && MODDIRNAME=modules_update
  local MODULEROOT=$NVBASE/$MODDIRNAME
  MODID=`grep_prop id $TMPDIR/module.prop`
  MODNAME=`grep_prop name $TMPDIR/module.prop`
  MODAUTH=`grep_prop author $TMPDIR/module.prop`
  MODPATH=$MODULEROOT/$MODID

  # Create mod paths
  rm -rf $MODPATH
  mkdir -p $MODPATH

  if is_legacy_script; then
    package_extract_dir $DNM $TMPDIR
    # Load install script
    magisk_print
    . $TMPDIR/install.sh

    # Callbacks
    on_install

    [ -f $TMPDIR/uninstall.sh ] && cp -af $TMPDIR/uninstall.sh $MODPATH/uninstall.sh
    $SKIPMOUNT && touch $MODPATH/skip_mount
    $PROPFILE && cp -af $TMPDIR/system.prop $MODPATH/system.prop
    cp -af $TMPDIR/module.prop $MODPATH/module.prop
    $POSTFSDATA && cp -af $TMPDIR/post-fs-data.sh $MODPATH/post-fs-data.sh
    $LATESTARTSERVICE && cp -af $TMPDIR/service.sh $MODPATH/service.sh

    set_permissions
  else
    magisk_print

    package_extract_file $DNM/customize.sh $MODPATH/customize.sh

    if ! grep -q '^SKIPUNZIP=1$' $MODPATH/customize.sh 2>/dev/null; then
      package_extract_dir $DNM $MODPATH

      # Default permissions
      echo2 "- Setting common permissions/contexts"
      echo2 " "
      set_perm_recursive2 0 0 $di_perm_d $di_perm_f $MODPATH
      ch_con_recursive system_file system_file $MODPATH
      for perm in /system/bin /system/xbin /system/system_ext/bin /system/vendor/bin; do
         if [ -d "$MODPATH$perm" ]; then
            set_perm_recursive2 0 2000 0755 0755 "$MODPATH$perm"
         fi
      done
      if [ -d "$MODPATH/system/vendor" ]; then ch_con_recursive vendor_file vendor_file "$MODPATH/system/vendor"; fi
      unset perm
    fi

    # Load customization script
    [ -f $MODPATH/customize.sh ] && . $MODPATH/customize.sh
  fi

  # Handle replace folders
  for TARGET in $REPLACE; do
    echo2 "- Replace target: $TARGET"
    mktouch $MODPATH$TARGET/.replace
  done

  if $BOOTMODE; then
    # Update info for Magisk app
    mktouch $NVBASE/modules/$MODID/update
    rm -rf $NVBASE/modules/$MODID/remove 2>/dev/null
    rm -rf $NVBASE/modules/$MODID/disable 2>/dev/null
    cp -af $MODPATH/module.prop $NVBASE/modules/$MODID/module.prop
  fi

  # Copy over custom sepolicy rules
  if [ -f $MODPATH/sepolicy.rule ]; then
    echo2 "- Installing custom sepolicy rules"
    copy_sepolicy_rules
  fi

  # Remove stuff that doesn't belong to modules and clean up any empty directories
  rm -rf \
  $MODPATH/system/placeholder $MODPATH/customize.sh \
  $MODPATH/README.md $MODPATH/.git*
  rmdir -p $MODPATH

  cd /
  if [[ "$run_addons" == "on" ]]; then
    while read addon; do
       if exist "$addon"; then . "$addon"; fi
    done <<< $(find "$addons" -mindepth 1 -maxdepth 1 -type f -name "*.sh")
  fi
  $BOOTMODE || recovery_cleanup
  rm -rf $TMPDIR

}

if [ $MAGISK_VER_CODE -ge 20400 ]; then
  # New Magisk have complete installation logic within util_functions.sh
  echo2 "----------------Running SCRIPTs------------"
  install_module
  restore_env
  echo2 "-------------------------------------------"
  exit 0
fi

fi

